%\VignetteEngine{knitr::knitr}
\documentclass{article}

\usepackage{graphicx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage[table]{xcolor}
\usepackage{amsmath}
\setlength{\textfloatsep}{10pt plus 1.0pt minus 2.0pt}
%\newcommand{\sectionbreak}{\clearpage}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# Set options
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, cache=TRUE)
options(replace.assign=TRUE,width=90)
par.original <- par()
days.per.month <- 30.4368
days.per.year <- 365.242
package.dir <- "~/repos/MetaGx/"
@

\title{Robustness of Ovarian Subtyping Schemes}

\author{Gregory M. Chen}
\date{\today}
\maketitle

<<load, cache=FALSE>>=
library(gdata)
library(knitr)
library(HiDimDA)
library(survival)
library(reshape2)
library(genefu)
library(annotate)
library(hgu133plus2.db)
library(stringr)
# library(survMisc) 
library(xtable)
library(gridExtra)
library(Biobase)
library(GSVA)
library(sparsediscrim)
library(MetaGxOvarian)
library(survcomp)
library(ggplot2)
library(e1071)
library(randomForest)
library(NMF)
library(clue)
library(GEOquery)
@

<<load_data>>=
#
#source(system.file("extdata", "reproduce.results.patientselection.config", package="MetaGx2"))
#source(system.file("extdata", "patientselection.config", package="MetaGxOvarian"))

source("../../inst/extdata/reproduce.results.patientselection.config")

rm(probe.gene.mapping)
rescale <- FALSE
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.not.rescaled.probes <- esets

probe.gene.mapping <- TRUE
rule.2 <- c("histological_type","^ser$")
rule.3 <- c("summarystage","^late$")
rule.4 <- c("summarygrade","^high$")
### use this line if you do not want to get rid of duplicates
rm(remove.duplicates)

source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.not.rescaled <- esets

esets.quantile.norm <- esets.not.rescaled
esets.quantile.norm <- lapply(esets.quantile.norm, function(eset) {
  ee <- exprs(eset)
      # ee <- apply(ee, 2, genefu::rescale)
      splitix <- parallel::splitIndices(nx=ncol(ee), ncl=4)
      mcres <- parallel::mclapply(splitix, function(x, data) {
        res <- apply(data[ , x, drop=FALSE], 2, function (dx) {
          return ((genefu::rescale(dx, q=0.05, na.rm=TRUE) - 0.5) * 2)
        })
        return (res)
      }, data=ee, mc.cores=4)
      ee <- do.call(cbind, mcres)
      ## quantile normalization
      ee <- limma::normalizeBetweenArrays(object=ee, method="quantile")
      exprs(eset) <- ee
  return(eset)
})


rescale <- TRUE
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.rescale.by.gene <- esets
rm(esets)
@
%\tableofcontents 


<<cluster_functions>>=
.getFilteredEsetByMAD <- function(eset, num.genes) {
  expression.matrix <- exprs(eset)
  mad.vals <- apply(expression.matrix, 1, mad)
  # expression.matrix has genes as rows, patients as columns
  eset <- eset[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  return(eset)
}

.getFilteredEsetByGeneList <- function(eset, gene.list, list.type=c("gene.symbol", "entrez.id")) {
  list.type <- match.arg(list.type)
  if(list.type == "gene.symbol") {
    eset <- eset[fData(eset)$gene %in% gene.list,]
  } else if(list.type == "entrez.id") {
    eset <- eset[fData(eset)$EntrezGene.ID %in% gene.list,]
  }
}

.getNMFClasses <- function(eset, filter.genes=TRUE, num.genes=2000, rank=4, nrun=100) {
  # rescale eset by z-score per gene
  expression.matrix <- exprs(eset)
  if(filter.genes) {
    mad.vals <- apply(exprs(eset), 1, mad)
    expression.matrix <- exprs(eset)[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  }
  if(any(expression.matrix < 0)) {
    expression.matrix <- expression.matrix + abs(min(expression.matrix))
  }
  
  nmf.out <- nmf(expression.matrix, rank=rank, nrun=nrun)
  # Clustering using consensus
  classes <- cutree(consensushc(nmf.out, dendrogram=FALSE), k=rank)
  
  classes <- as.factor(paste0("ConsensusNMF_", classes))
  # Clustering using matrix factorization
  #h.mat <- coef(nmf.out)
  #classes <- apply(h.mat, 2, which.max)
  #classes <- as.factor(paste0("NMF_", classes))
  return(classes)
}

.getConsensusKMeansClasses <- function(eset, filter.genes=TRUE, num.genes=2000, k=4, num.iterations=100) {
  expression.matrix <- exprs(eset)
  if(filter.genes) {
    mad.vals <- apply(exprs(eset), 1, mad)
    expression.matrix <- exprs(eset)[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  }
  expression.matrix <- t(expression.matrix)
  kmeans.out <- lapply(1:100, function(x) kmeans(expression.matrix, centers = k))
  cl.ensemble <- cl_ensemble(list=kmeans.out)
  consensus.out <- cl_consensus(cl.ensemble)
  membership.matrix <- matrix(as.vector(consensus.out$.Data), nrow=ncol(eset))
  
  classes <- apply(membership.matrix, 1, which.max)
  classes <- as.factor(paste0("kmeans_", classes))
  return(classes)
}
@

%TCGA

\section{TCGA}

<<TCGA_clustering_mad>>=
# Filter to 1500 genes by top median absolute deviation
set.seed(110)
tcga.clustering.authordata <- read.delim("../../inst/extdata/TCGA_489_UE.top1500.txt", sep="\t")

verhaak.spreadsheet.data <- read.xls("../../inst/extdata/JCI65833sd1.xls", skip=1)
verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE", "SILHOUETTE.WIDTH")]

tcga.eset <- esets.not.rescaled$TCGA
tcga.eset <- tcga.eset[,tcga.eset$unique_patient_ID %in% verhaak.labels.table$ID]

tcga.implemented.clustering.mad <- data.frame(ID=tcga.eset$unique_patient_ID, nmf.classes=.getNMFClasses(tcga.eset, num.genes = 1500, nrun=100))

tcga.eset.mad.1500 <- .getFilteredEsetByMAD(tcga.eset, 1500)
mad.1500.gene.list <- fData(tcga.eset.mad.1500)$gene

tcga.merged.mad <- merge(tcga.implemented.clustering.mad, verhaak.labels.table)
@

In the TCGA study (2011), the authors performed clustering as follows. First, the gene list was filtered to genes that correlate above 0.7 between each of three microarray platforms and the unified estimate; then, the top 1500 genes by median absolute deviation (MAD) were selected. Clustering was performed by non-negative matrix factorization.

In order to perform clustering across datasets, we selected the top 1500 genes by MAD, then performed non-negative matrix factorization with 100 iterations. 
\vspace*{10pt}
<<TCGA_contingency_mad, results="asis">>=
kable(table(tcga.merged.mad$SUBTYPE, tcga.merged.mad$nmf.classes)[c(3,4,1,2),c(4,2,3,1)], format="latex")
@

%TCGA et al. performed analysis subtypes after filtering out the lowest approximately 10\% of samples by silhouette width. %Considering only these samples, we get the following table.
%
%<<TCGA_contingency_mad_silhouette, results="asis">>=
%tcga.merged.mad.silhouette <- tcga.merged.mad[tcga.merged.mad$SILHOUETTE.WIDTH > quantile(tcga.merged.mad$SILHOUETTE.WIDTH, 0.1),]
%kable(table(tcga.merged.mad.silhouette$SUBTYPE, tcga.merged.mad.silhouette$nmf.classes)[c(1,2,3,4),], format="latex")
%

<<tcga_mad_contingency_heatmap, fig.width=6, fig.height=4, out.width="0.4\\textwidth">>=
.getContingencyHeatmap(table(tcga.merged.mad$SUBTYPE, tcga.merged.mad$nmf.classes)[c(3,4,1,2),c(4,2,3,1)])
@

This procedure was repeated 16 times, and we observed relatively stable clustering (with the exception of Differentiated and Immunoreactive classes sometimes clustering together, as in the centre-bottom-left image).

<<tcga_merged_mad_multiple, fig.width=24, fig.height=16, out.width="1\\textwidth">>=
#plots <- lapply(1:16, function(i) {
#  load(paste0("tcga.merged.mad.", i, ".RData"))
#  .getContingencyHeatmap(table(tcga.merged.mad$SUBTYPE, tcga.merged.mad$nmf.classes))
#})
#do.call(gridExtra::grid.arrange, plots)

my.plots <- lapply(1:16, function(i) {
  load(paste0("tcga.merged.mad.consensus.", i, ".RData"))
  .getContingencyHeatmap(table(tcga.merged.mad.consensus$SUBTYPE, tcga.merged.mad.consensus$nmf.classes)[c(3,4,1,2),])
})
do.call(gridExtra::grid.arrange, my.plots)
@

<<TCGA_clustering_authorlist>>=
set.seed(120)
tcga.clustering.authordata <- read.delim("../../inst/extdata/TCGA_489_UE.top1500.txt", sep="\t")

tcga.gene.indices <- match(rownames(tcga.clustering.authordata), fData(esets.not.rescaled$TCGA)$gene)
tcga.gene.indices <- tcga.gene.indices[!is.na(tcga.gene.indices)]

verhaak.spreadsheet.data <- read.xls("../../inst/extdata/JCI65833sd1.xls", skip=1)
verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE")]

tcga.eset <- esets.not.rescaled$TCGA
tcga.eset <- tcga.eset[,tcga.eset$unique_patient_ID %in% verhaak.labels.table$ID]

tcga.implemented.clustering.authorlist <- data.frame(ID=tcga.eset$unique_patient_ID, nmf.classes=.getNMFClasses(tcga.eset[tcga.gene.indices,], filter.genes = FALSE, nrun=100))

tcga.merged.authorlist <- merge(tcga.implemented.clustering.authorlist, verhaak.labels.table)
@


We contacted the authors to acquire the original gene list used for clustering.\footnote{Out of 1500 genes, there was an overlap of \Sexpr{length(intersect(rownames(tcga.clustering.authordata), mad.1500.gene.list))}. The difference is likely due to the correlation step across platforms, which the original gene list did not account for.} The clusters appeared similar.
\vspace*{10pt}
<<TCGA_contingency_authorlist, results="asis">>=

kable(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),c(3,4,2,1)], format="latex")
@

<<tcga_authorlist_contingency_heatmap, fig.width=6, fig.height=4, out.width="0.4\\textwidth">>=

.getContingencyHeatmap(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),c(3,4,2,1)])
@

Repeating this process 16 times:
<<tcga_authorlist_repeated, fig.width=24, fig.height=16, out.width="1\\textwidth">>=
my.plots <- lapply(1:16, function(i) {
  load(paste0("tcga.merged.authorlist.", i, ".RData"))
  .getContingencyHeatmap(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),])
})
do.call(gridExtra::grid.arrange, my.plots)
@

%Considering only the samples after removing the bottom 10\% by silhouette width:
%<<TCGA_contingency_authorlist_silhouette, results="asis">>=
%verhaak.spreadsheet.data <- read.xls("../../inst/extdata/JCI65833sd1.xls", skip=1)
%verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE", %"SILHOUETTE.WIDTH")]
%tcga.merged.authorlist <- merge(tcga.implemented.clustering.authorlist, verhaak.labels.table)
%tcga.merged.authorlist.silhouette <- tcga.merged.authorlist[tcga.merged.authorlist$SILHOUETTE.WIDTH > quantile(tcga%.merged.authorlist$SILHOUETTE.WIDTH, 0.1)]
%kable(table(tcga.merged.authorlist.silhouette$SUBTYPE, tcga.merged.authorlist.silhouette$nmf.classes)[,], format="latex")
%@


%Konecny

\section{Konecny}

<<Konecny_clustering>>=
set.seed(840)

load("konecny.eset.RData")
konecny.unique.entrez.ids <- scan("../../inst/extdata/konecny.unique.entrez.ids.txt", what=character(0))
## These files were generated on August 5, 2015 with the following code:
konecny.original.eset <- getGEO("GSE53963", GSEMatrix=TRUE)[[1]]
#konecny.mad.vals <- apply(exprs(konecny.original.eset), 1, function(x) mad(x, na.rm=TRUE))
#konecny.eset <- konecny.original.eset
#fData(konecny.eset) <- fData(konecny.eset)[,c("ID", "GENE_SYMBOL", "GENE")]
#colnames(fData(konecny.eset)) <- c("probeset", "gene", "EntrezGene.ID")
#fData(konecny.eset)$best_probe <- FALSE
 #remove NA probes
#konecny.eset <- konecny.eset[apply(exprs(konecny.eset), 1, function(x) all(!is.na(x))),]
#konecny.eset <- konecny.eset[!is.na(fData(konecny.eset)$EntrezGene.ID) & fData(konecny.eset)$EntrezGene.ID != "",]
#for(konecny.entrez.id in unique(fData(konecny.eset)$EntrezGene.ID)) {
#  probe.indices <- which(fData(konecny.eset)$EntrezGene.ID == konecny.entrez.id)
#  probe.index.to.keep <- probe.indices[which.max(apply(exprs(konecny.eset)[probe.indices,,drop=FALSE], 1, var))]
#  fData(konecny.eset)$best_probe[probe.index.to.keep] <- TRUE
#}
#konecny.eset.probest
#konecny.eset <- konecny.eset[fData(konecny.eset)$best_probe,]
#rownames(konecny.eset) <- paste0("geneid.", fData(konecny.eset)$EntrezGene.ID)
save(konecny.original.eset, file="konecny.original.eset.RData")
save(konecny.eset, file="konecny.eset.RData")

konecny.supp5 <- read.xls("../../inst/extdata/jnci_JNCI_14_0249_s05.xls", header=FALSE)
#konecny.unique.entrez.ids <- fData(konecny.original.eset)$GENE[ fData(konecny.original.eset)$ID %in% konecny.supp5$V2 ]
#konecny.unique.entrez.ids <- konecny.unique.entrez.ids[!is.na(konecny.unique.entrez.ids) & konecny.unique.entrez.ids != ""]
#konecny.unique.entrez.ids <- unique(konecny.unique.entrez.ids)
#save(konecny.unique.entrez.ids, file="konecny.unique.entrez.ids.RData")
#write(konecny.unique.entrez.ids, file="../../inst/extdata/konecny.unique.entrez.ids.txt", ncolumns = 1)

konecny.original.eset.tocluster <- konecny.original.eset
fData(konecny.original.eset.tocluster) <- fData(konecny.original.eset.tocluster)[,c("ID", "GENE_SYMBOL", "GENE")]
colnames(fData(konecny.original.eset.tocluster)) <- c("probeset", "gene", "EntrezGene.ID")
konecny.mad.vals <- apply(exprs(konecny.original.eset.tocluster), 1, function(x) mad(x, na.rm=TRUE))
konecny.original.eset.tocluster <- konecny.original.eset.tocluster[konecny.mad.vals >= tail(sort(konecny.mad.vals), 2500)[1],]

# only keep non-NA probes
konecny.original.eset.tocluster <- konecny.original.eset.tocluster[apply(exprs(konecny.original.eset.tocluster), 1, function(x) all(!is.na(x))),]

konecny.eset.original.genes <- .getFilteredEsetByGeneList(eset = konecny.eset, gene.list = konecny.unique.entrez.ids, list.type = "entrez.id")
konecny.implemented.clustering.authorlist <- data.frame(OV=sub("[A-Za-z ]*", "", konecny.eset$source_name_ch2), nmf.classes=.getNMFClasses(konecny.eset.original.genes, filter.genes = FALSE, nrun=100))

konecny.supp3 <- read.xls("../../inst/extdata/jnci_JNCI_14_0249_s03.xls")
konecny.labels.table <- konecny.supp3[,c("OV", "MAYO.C4")]

konecny.merged.authorlist <- merge(konecny.implemented.clustering.authorlist, konecny.labels.table)

@

Konecny et al. performed clustering by first taking a subset of the top 2500 probesets by median absolute deviation (MAD), then used non-negative matrix factorization. We matched these probeset names to Entrez IDs from data from GEO, and performed clustering on the series matrix from GEO. In order to ensure all expression values were positive, all expression quantities were increased by the absolute value of the smallest (most negative) value. We ran NMF with 100 iterations, and used hierarchical clustering on the co-membership matrix to define consensus cluster groupings.


\vspace*{10pt}
<<konecny_contingency_authorlist, results="asis">>=
kable(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),c(3,2,4,1)], format="latex")

@

<<konecny_contingency_heatmap, fig.width=5, fig.height=4, out.width="0.4\\textwidth">>=
# table with rows published labels, columns de novo labels
.getContingencyHeatmap <- function(contingency.table) {
    contingency.table <- contingency.table[nrow(contingency.table):1,]
    contingency.matrix <- as.matrix(contingency.table)
    contingency.m <- melt(contingency.matrix)
    colnames(contingency.m) <- c("Published.classes", "New.cluster.classes", "value")
    
   # contingency.m$Published.classes <- factor(contingency.m$Published.classes, levels=rev(levels(contingency.m$Published.classes)))
    
    p <- ggplot(contingency.m, aes_string("New.cluster.classes", "Published.classes")) + 
      geom_tile(aes(fill = value), colour = "white") + 
      #scale_fill_gradient(name="Frequency", low="white", high="#CC0000", limits=c(0,800)) + 
      #ggtitle(paste0("Contingency table: ", subtype.name.pair[1], " vs ", subtype.name.pair[2])) +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) +
    
      geom_text(label=as.character(contingency.matrix), colour="white")
    return(p)
}
.getContingencyHeatmap(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),c(3,2,4,1)])
@

To get a feel for the consistency of the clustering procedure to random seeds, I performed the same clustering procedure (consensus NMF clustering with 100 iterations each) sixteen times. While the clusters were fairly consistent, in some cases (e.g. top-left) the consensus NMF clustering appeared to return only three clusters.\footnote{This could be due to the last step of the consensus NMF clustering that I used, which uses hierarchical clustering. It is unclear from the authors' description what method they used to generate the consensus classes.}

<<konecny_16_plots, fig.width=24, fig.height=16, out.width="1\\textwidth">>=
my.plots <- lapply(1:16, function(i) {
  load(paste0("konecny.merged.authorlist.", i, ".RData"))
  .getContingencyHeatmap(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),])
})
do.call(gridExtra::grid.arrange, my.plots)
@


%Tothill
\section{Tothill}

<<Tothill_clustering>>=
set.seed(132)
tothill.original.labels <- read.table("../../inst/extdata/tothill.supptable.1.classes.txt", header=TRUE, stringsAsFactors = FALSE)
tothill.original.labels <- tothill.original.labels[tothill.original.labels$group %in% c(1, 2, 3, 4, 5, 6),]
tothill.original.labels$group <- sub("^", "C", tothill.original.labels$group)
tothill.original.labels.hgs <- tothill.original.labels[tothill.original.labels$group %in% c("C1", "C2", "C4", "C5"),]

if(file.exists("../../inst/extdata/tothill.clustering.probesets.txt")) {
  tothill.clustering.probesets <- scan("../../inst/extdata/tothill.clustering.probesets.txt")
}

tothill.clustering.genes <- read.table("../../inst/extdata/tothill.clustering.genes.txt")
## This file was generated on July 31, 2015 with the following code:
#original.tothill.eset <- getGEO("GSE9891", GSEMatrix=TRUE)[[1]]
#original.tothill.eset <- original.tothill.eset[apply(exprs(original.tothill.eset), 1, function(x) any(x > 7) & var(x) >= 0.5),]
#tothill.clustering.genes <- data.frame(probe=fData(original.tothill.eset)$ID, entrez.id=fData(original.tothill.eset)$ENTREZ_GENE_ID)
#write.table(tothill.clustering.genes, file="../../inst/extdata/tothill.clustering.genes.txt")

tothill.implemented.clustering.kmeans <- data.frame(ID=esets.not.rescaled.probes$GSE9891$alt_sample_name, consensus.kmeans.classes=.getConsensusKMeansClasses(esets.not.rescaled.probes$GSE9891, k=6, num.iterations=1000))

tothill.implemented.clustering.kmeans$ID <- sub("X", "", tothill.implemented.clustering.kmeans$ID)

tothill.merged.kmeans <- merge(tothill.implemented.clustering.kmeans, tothill.original.labels)
@

The dataset of Tothill et al. (2008) consisted of \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)} patients, of which \Sexpr{ncol(esets.not.rescaled$GSE9891)} had late-stage, high-grade serious ovarian cancer. On their full dataset (n = \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)}), they performed the following clustering procedure: probes were selected if at least one sample had an expression above 7.0, and global variance was above 0.5. They performed a form of consensus k-means clustering by performing k-means clustering 1000 times, identifyied a ``robust'' set of samples that co-clustered consistently, then used diagonal LDA and k-nearest neighbours to classify remaining samples. 

Using their full dataset, we filtered to probes with at least one sample with expression above 7.0, and variance above 0.5. We performed k-means clustering $B = 1000$ times, and used \texttt{R} package \texttt{clue} to perform consensus clustering using the criterion of Dimitriadou et al. (2002):
\begin{align*}
C_{\textnormal{consensus}} = \min_{C\in\mathcal{C}} \left\{ \sum_{b=1}^B d(C,C_b)^2 \right\}
\end{align*}
where $\mathcal{C}$ is the set of all possible clusterings, $d$ is the Euclidean distance, and $\{C_1, C_2, \ldots, C_B\}$ are the k-means clusterings.

Despite the difference between the consensus strategies, the cluster results appear to be similar:

\vspace*{10pt}
<<tothill_kmeans_contingency, results="asis">>=
kable(table(tothill.merged.kmeans$group, tothill.merged.kmeans$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(3,1,6,2,5,4)], format="latex")
#table(tothill.merged$nmf.classes, tothill.merged$group)
@
\vspace*{10pt}

<<tothill_6_contingency_heatmap, fig.width=5, fig.height=4, out.width="0.4\\textwidth">>=
.getContingencyHeatmap(table(tothill.merged.kmeans$group, tothill.merged.kmeans$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(3,1,6,2,5,4)])
@

<<tothill_kmeans_5_clustering>>=
tothill.implemented.clustering.kmeans.5 <- data.frame(ID=esets.not.rescaled.probes$GSE9891$alt_sample_name, consensus.kmeans.classes=.getConsensusKMeansClasses(esets.not.rescaled.probes$GSE9891, k=5, num.iterations=1000))
tothill.implemented.clustering.kmeans.5$ID <- sub("X", "", tothill.implemented.clustering.kmeans.5$ID)
tothill.merged.kmeans.5 <- merge(tothill.implemented.clustering.kmeans.5, tothill.original.labels)
@

Since it appears that this implementation of k-means clustering is not capturing C6, we performed consensus k-means clustering with k = 5:
\vspace*{10pt}
<<tothill_kmeans_5_contingency, results="asis">>=
kable(table(tothill.merged.kmeans.5$group, tothill.merged.kmeans.5$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(4,5,2,1,3)], format="latex")
@
\vspace*{10pt}
<<tothill_5_contingency_heatmap, fig.width=5, fig.height=4, out.width="0.4\\textwidth">>=
.getContingencyHeatmap(table(tothill.merged.kmeans.5$group, tothill.merged.kmeans.5$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(4,5,2,1,3)])
@

Since both Konecny / TCGA used NMF of rank 4, it seemed interesting to investigate how this algorithm would perform on the Tothill dataset. The top 3000 genes were selected by top MAD, and NMF was performed. 



NMF with rank = 4:

<<tothill_nmf_clustering, eval=FALSE>>=

tothill.implemented.clustering.nmf <- data.frame(ID=esets.not.rescaled$GSE9891$alt_sample_name, nmf.classes=.getNMFClasses(esets.not.rescaled$GSE9891, num.genes = 3000, nrun=100))
tothill.implemented.clustering.nmf$ID <- sub("X", "", tothill.implemented.clustering.nmf$ID)
tothill.merged.nmf <- merge(tothill.implemented.clustering.nmf, tothill.original.labels.hgs)
@
\vspace*{10pt}
<<tothill_nmf_contingency, results="asis", eval=FALSE>>=
kable(table(tothill.merged.nmf$group, tothill.merged.nmf$nmf.classes)[c(1,4,3,2),c(2,3,4,1)], format="latex")
#table(tothill.merged$nmf.classes, tothill.merged$group)
@

<<tothill_4_contingency_heatmap, fig.width=5, fig.height=4, out.width="0.4\\textwidth", eval=FALSE>>=
.getContingencyHeatmap(table(tothill.merged.nmf$group, tothill.merged.nmf$nmf.classes)[c(1,4,3,2),c(2,3,4,1)])
@

%Bentink
\pagebreak
\section{Preliminary work: Prediction Strength}

\Sexpr{knit_child('robustness_validation.Rnw')}

\end{document}