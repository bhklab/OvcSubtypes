%\VignetteEngine{knitr::knitr}
\documentclass{article}

\usepackage{graphicx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage[table]{xcolor}
\usepackage{amsmath}
%\newcommand{\sectionbreak}{\clearpage}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# Set options
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, cache=TRUE)
options(replace.assign=TRUE,width=90)
par.original <- par()
days.per.month <- 30.4368
days.per.year <- 365.242
package.dir <- "~/repos/MetaGx/"
@

\title{Robustness of Ovarian Subtyping Schemes}

\author{Gregory M. Chen}
\date{\today}
\maketitle

<<load, cache=FALSE>>=
library(gdata)
library(knitr)
library(HiDimDA)
library(survival)
library(reshape2)
library(genefu)
library(annotate)
library(hgu133plus2.db)
library(stringr)
# library(survMisc) 
library(xtable)
library(gridExtra)
library(Biobase)
library(GSVA)
library(sparsediscrim)
library(MetaGxOvarian)
library(survcomp)
library(ggplot2)
library(e1071)
library(randomForest)
library(NMF)
library(clue)
library(GEOquery)
@

<<load_data>>=
#
#source(system.file("extdata", "reproduce.results.patientselection.config", package="MetaGx2"))
#source(system.file("extdata", "patientselection.config", package="MetaGxOvarian"))

source("../../inst/extdata/reproduce.results.patientselection.config")

rm(probe.gene.mapping)
rescale <- FALSE
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.not.rescaled.probes <- esets

probe.gene.mapping <- TRUE
rule.2 <- c("histological_type","^ser$")
rule.3 <- c("summarystage","^late$")
rule.4 <- c("summarygrade","^high$")
### use this line if you do not want to get rid of duplicates
rm(remove.duplicates)

source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.not.rescaled <- esets

esets.quantile.norm <- esets.not.rescaled
esets.quantile.norm <- lapply(esets.quantile.norm, function(eset) {
  ee <- exprs(eset)
      # ee <- apply(ee, 2, genefu::rescale)
      splitix <- parallel::splitIndices(nx=ncol(ee), ncl=4)
      mcres <- parallel::mclapply(splitix, function(x, data) {
        res <- apply(data[ , x, drop=FALSE], 2, function (dx) {
          return ((genefu::rescale(dx, q=0.05, na.rm=TRUE) - 0.5) * 2)
        })
        return (res)
      }, data=ee, mc.cores=4)
      ee <- do.call(cbind, mcres)
      ## quantile normalization
      ee <- limma::normalizeBetweenArrays(object=ee, method="quantile")
      exprs(eset) <- ee
  return(eset)
})


rescale <- TRUE
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.rescale.by.gene <- esets
rm(esets)
@
%\tableofcontents 


<<cluster_functions>>=
.getFilteredEsetByMAD <- function(eset, num.genes) {
  expression.matrix <- exprs(eset)
  mad.vals <- apply(expression.matrix, 1, mad)
  # expression.matrix has genes as rows, patients as columns
  eset <- eset[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  return(eset)
}

.getFilteredEsetByGeneList <- function(eset, gene.list, list.type=c("gene.symbol", "entrez.id")) {
  list.type <- match.arg(list.type)
  if(list.type == "gene.symbol") {
    eset <- eset[fData(eset)$gene %in% gene.list,]
  } else if(list.type == "entrez.id") {
    eset <- eset[fData(eset)$EntrezGene.ID %in% gene.list,]
  }
}

.getNMFClasses <- function(eset, filter.genes=TRUE, num.genes=2000, rank=4, nrun=100) {
  
  nmf.out <- nmf(expression.matrix, rank=rank, nrun=nrun)
  h.mat <- coef(nmf.out)
  classes <- apply(h.mat, 2, which.max)
  classes <- as.factor(paste0("NMF_", classes))
  return(classes)
}

.getConsensusKMeansClasses <- function(eset, filter.genes=TRUE, num.genes=2000, k=4, num.iterations=100) {
  # rescale eset by z-score per gene
  expression.matrix <- exprs(eset)
  if(filter.genes) {
    mad.vals <- apply(exprs(eset), 1, mad)
    expression.matrix <- exprs(eset)[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  }
  expression.matrix <- t(expression.matrix)
  kmeans.out <- lapply(1:100, function(x) kmeans(expression.matrix, centers = k))
  cl.ensemble <- cl_ensemble(list=kmeans.out)
  consensus.out <- cl_consensus(cl.ensemble)
  membership.matrix <- matrix(as.vector(consensus.out$.Data), nrow=ncol(eset))
  
  classes <- apply(membership.matrix, 1, which.max)
  classes <- as.factor(paste0("kmeans_", classes))
  return(classes)
}
@

%Konecny

<<Konecny_clustering>>=

## This file was generated on July 31, 2015 with the following code:
#konecny.original.eset <- getGEO("GSE53963", GSEMatrix=TRUE)[[1]]
#konecny.mad.vals <- apply(exprs(konecny.original.eset), 1, function(x) mad(x, na.rm=TRUE))
#konecny.subset <- konecny.original.eset[konecny.mad.vals >= tail(sort(konecny.mad.vals),2500)[[1]],]
#konecny.subset <- konecny.subset[apply(exprs(konecny.subset), 1, function(x) sum(is.na(x)) < 20),]
#konecny.unique.gene.symbols <- unique(as.character(fData(konecny.subset)$GENE_SYMBOL))
#konecny.unique.gene.symbols <- konecny.unique.gene.symbols[konecny.unique.gene.symbols != ""]

@

%TCGA
<<TCGA_clustering>>=
# Filter to 1500 genes by top median absolute deviation
set.seed(109)
tcga.clustering.authordata <- read.delim("../../inst/extdata/TCGA_489_UE.top1500.txt", sep="\t")

tcga.gene.indices <- match(rownames(tcga.clustering.authordata), fData(esets.not.rescaled$TCGA)$gene)
tcga.gene.indices <- tcga.gene.indices[!is.na(tcga.gene.indices)]
tcga.expression.matrix.to.cluster <- exprs(esets.not.rescaled$TCGA)[tcga.gene.indices,]

verhaak.spreadsheet.data <- read.xls("../../inst/extdata/JCI65833sd1.xls", skip=1)
verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE")]

tcga.eset <- esets.not.rescaled$TCGA
tcga.eset <- tcga.eset[tcga.eset$unique_patient_ID %in% verhaak.labels.table$ID,]

tcga.implemented.clustering <- data.frame(ID=tcga.eset$unique_patient_ID, nmf.classes=.getNMFClasses(tcga.eset[tcga.gene.indices,], num.genes = 1500, nrun=50))

tcga.merged <- merge(tcga.implemented.clustering, verhaak.labels.table)
@

In the TCGA study (2011), the authors performed clustering as follows. First, the gene list was filtered to genes that correlate above 0.7 between each of three microarray platforms and the unified estimate; then, the top 1500 genes by median absolute deviation (MAD) were selected. Clustering was performed by non-negative matrix factorization.

In order to perform clustering across datasets, we selected the top 1500 genes by MAD, then performed non-negative matrix factorization with 100 iterations. 

<<TCGA_contingency, results="asis">>=
kable(table(tcga.merged$SUBTYPE, tcga.merged$nmf.classes)[c(1,2,4,3),], format="latex")
@

%Tothill

<<Tothill_clustering>>=
set.seed(132)
tothill.original.labels <- read.table("../../inst/extdata/tothill.supptable.1.classes.txt", header=TRUE, stringsAsFactors = FALSE)
tothill.original.labels <- tothill.original.labels[tothill.original.labels$group %in% c(1, 2, 3, 4, 5, 6),]
tothill.original.labels$group <- sub("^", "C", tothill.original.labels$group)
tothill.original.labels.hgs <- tothill.original.labels[tothill.original.labels$group %in% c("C1", "C2", "C4", "C5"),]

if(file.exists(""../../inst/extdata/tothill.clustering.probesets.txt"")) {
  tothill.clustering.probesets <- scan("../../inst/extdata/tothill.clustering.probesets.txt")
}

tothill.clustering.genes <- read.table("../../inst/extdata/tothill.clustering.genes.txt")
## This file was generated on July 31, 2015 with the following code:
#original.tothill.eset <- getGEO("GSE9891", GSEMatrix=TRUE)[[1]]
#original.tothill.eset <- original.tothill.eset[apply(exprs(original.tothill.eset), 1, function(x) any(x > 7) & var(x) >= 0.5),]
#tothill.clustering.genes <- data.frame(probe=fData(original.tothill.eset)$ID, entrez.id=fData(original.tothill.eset)$ENTREZ_GENE_ID)
#write.table(tothill.clustering.genes, file="../../inst/extdata/tothill.clustering.genes.txt")

tothill.cluster.entrez.ids <- 
tothill.gene.indices <- match(tothill.cluster.entrez.ids, fData(esets.rescale.by.gene$GSE9891)$EntrezGene.ID)
tothill.expression.matrix.to.cluster <- exprs(esets.rescale.by.gene$GSE9891[tothill.gene.indices,])
tothill.expression.matrix.to.cluster <- tothill.expression.matrix.to.cluster[apply(tothill.expression.matrix.to.cluster, 1, function(x) all(!is.na(x))),]
tothill.expression.matrix.to.cluster <- t(tothill.expression.matrix.to.cluster)

tothill.implemented.clustering.kmeans <- data.frame(ID=esets.not.rescaled.probes$GSE9891$alt_sample_name, consensus.kmeans.classes=.getConsensusKMeansClasses(esets.not.rescaled.probes$GSE9891, k=6))

tothill.implemented.clustering.kmeans$ID <- sub("X", "", tothill.implemented.clustering.kmeans$ID)

tothill.merged.kmeans <- merge(tothill.implemented.clustering.kmeans, tothill.original.labels)
@

The dataset of Tothill et al. (2008) consisted of \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)} patients, of which \Sexpr{ncol(esets.not.rescaled$GSE9891)} had late-stage, high-grade serious ovarian cancer. On their full dataset (n = \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)}), they performed the following clustering procedure: probes were selected if at least one sample had an expression above 7.0, and global variance was above 0.5. They performed a form of consensus k-means clustering by performing k-means clustering 1000 times, identifyied a ``robust'' set of samples that co-clustered consistently, then used diagonal LDA and k-nearest neighbours to classify remaining samples. 

Using their full dataset, we filtered to probes with at least one sample with expression above 7.0, and variance above 0.5. We performed k-means clustering $B = 1000$ times, and used \texttt{R} package \texttt{clue} to perform consensus clustering using the criterion of Dimitriadou et al. (2002):
\begin{align*}
C_{\textnormal{consensus}} = \min_{C\in\mathcal{C}} \left\{ \sum_{b=1}^B d(C,C_b)^2 \right\}
\end{align*}
where $\mathcal{C}$ is the set of all possible clusterings, $d$ is the Euclidean distance, and $\{C_1, C_2, \ldots, C_B\}$ are the k-means clusterings.

<<tothill_kmeans_contingency, results="asis">>=
kable(table(tothill.merged.kmeans$consensus.kmeans.classes, tothill.merged.kmeans$group)[c(2,4,3,1,5),], format="latex")
#table(tothill.merged$nmf.classes, tothill.merged$group)
@

<<tothill_nmf_clustering>>=
tothill.implemented.clustering.nmf <- data.frame(ID=esets.not.rescaled$GSE9891$alt_sample_name, nmf.classes=.getNMFClasses(esets.not.rescaled$GSE9891, num.genes = 3000, nrun=5))
tothill.implemented.clustering.nmf$ID <- sub("X", "", tothill.implemented.clustering.nmf$ID)
tothill.merged.nmf <- merge(tothill.implemented.clustering.nmf, tothill.original.labels.hgs)
@

<<tothill_nmf_contingency, results="asis">>=
kable(table(tothill.merged.nmf$nmf.classes, tothill.merged.nmf$group)[c(3,1,4,2),], format="latex")
#table(tothill.merged$nmf.classes, tothill.merged$group)
@

%Bentink

\end{document}