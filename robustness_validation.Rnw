

<<load_data_original, eval=FALSE, cache=FALSE>>=
load("esets.not.rescaled.RData")

esets.not.rescaled <- esets.not.rescaled[names(esets.not.rescaled) != "TCGA.RNASeqV2"]
# Replace each gene by its z-score
esets <- lapply(esets.not.rescaled, function(eset) {
  exprs(eset) <- t(scale(t(exprs(eset))))
  return(eset)
})

source("../../R/getKonecnySubtypes.R")
source("../../R/getVerhaakSubtypes.R")
source("../../R/getHellandSubtypes.R")

# Subtype classification
esets <- lapply(esets, function(x) getKonecnySubtypes(x)[[1]])
esets <- lapply(esets, function(x) getVerhaakSubtypes(x)[[1]])
esets <- lapply(esets, function(x) getHellandSubtypes(x)[[1]])
esets.rescaled.with.subtype <- esets
save(esets.rescaled.with.subtype, file="esets.rescaled.with.subtype.RData")
rm(esets)
@


<<load_data_from_files, cache=FALSE>>=
load("esets.rescaled.with.subtype.RData")

# These are the dataset names with TCGA RNASeq removed
dataset.names <- c("E.MTAB.386", "GSE13876", "GSE14764",  "GSE17260",  "GSE18520",  "GSE20565",  "GSE2109",   "GSE26193",  "GSE26712",  "GSE32062",  "GSE49997",  "GSE51088",  "GSE9891",   "PMID17290060", "TCGA")

config.grid <- expand.grid(
  algorithm=c("nmf", "kmeans"),
  gene.set=c("tcga", "tothill", "konecny", "1000", "1500", "2000", "2500", "3000"),
  k=4)

cluster.class.list <- vector("list", nrow(config.grid))

for(i in 1:nrow(config.grid)) {
  cluster.classes <- list()
  for(current.eset.name in dataset.names) {
    cluster.classes[[current.eset.name]] <- scan(paste0("aug6clusters/", config.grid$gene.set[i], "_", config.grid$algorithm[i], "_", config.grid$k[i], "/", current.eset.name, "_classes.txt"), what=character(0))
  }
  cluster.class.list[[i]] <- cluster.classes
}

classifier.subtypes <- lapply(c("Konecny.subtypes", "Verhaak.subtypes", "Helland.subtypes"), function(subtype.colname) {
  subtype.classes <- list()
  for(current.eset.name in dataset.names) {
    subtype.classes[[current.eset.name]] <- as.character(pData(esets.rescaled.with.subtype[[current.eset.name]])[,subtype.colname])
  }
  return(subtype.classes)
})

names(classifier.subtypes) <- c("Konecny", "Verhaak", "Helland")

getAdjacencyMatrix <- function(classes) {
  adj.matrix <- matrix(NA, nrow=length(classes), ncol=length(classes))
	for(i in 1:(length(classes)-1)) {
		for(j in (i+1):length(classes)) {
			if(classes[i] == classes[j]) { adj.matrix[i,j] <- adj.matrix[j,i] <- 1 } else { adj.matrix[i,j] <- adj.matrix[j,i] <- 0 }
		}
	}
  return(adj.matrix)
}

getMeanAdjMatrices <- function(configs.to.keep) {
  cluster.class.list.tokeep <- cluster.class.list[configs.to.keep]
  lapply(names(cluster.class.list.tokeep[[1]]), function(dataset.name) {
  mean.adj.matrix <- matrix(0, nrow=length(cluster.class.list.tokeep[[1]][[dataset.name]]), ncol=length(cluster.class.list.tokeep[[1]][[dataset.name]]))
  total <- 0
  for(cluster.config.index in 1:length(cluster.class.list.tokeep)) {
    total <- total + 1
    cluster.classes <- cluster.class.list.tokeep[[cluster.config.index]]
    for(i in 1:(length(cluster.classes[[dataset.name]])-1)) {
      for(j in (i+1):length(cluster.classes[[dataset.name]])) {
        mean.adj.matrix[i,j] <- mean.adj.matrix[i,j] + (cluster.classes[[dataset.name]][i] == cluster.classes[[dataset.name]][j])
        mean.adj.matrix[j,i] <- mean.adj.matrix[j,i] + (cluster.classes[[dataset.name]][i] == cluster.classes[[dataset.name]][j])
      }
    }
  }
  mean.adj.matrix <- mean.adj.matrix / total
  diag(mean.adj.matrix) <- NA
  names(mean.adj.matrix) <- names(cluster.class.list[[1]])
  return(mean.adj.matrix)
})
}

#cluster.adjacency.list <- lapply(cluster.class.list, function(cluster.classes) {
#  lapply(cluster.classes, getAdjacencyMatrix)
#})

#cluster.adjacency.means <- do.call(function(x,y) {
#  for(i in 1:length(x)) sum(x[[i]], y[[i]], na.rm=TRUE)
#}, cluster.adjacency.list)

getMeanPairwiseSimilarityMeasure <- function(class.list, metricFunction) {
  out.vals <- c()
  for(i in 1:(length(class.list) - 1)) {
    for(j in (i+1):length(class.list)) {
      vals <- sapply(1:length(class.list[[i]]), function(x) metricFunction(class.list[[i]][[x]], class.list[[j]][[x]]))
      out.vals <- c(out.vals, vals)
    }
  }
  return(out.vals)
}
@


An important trait of a robust molecular subtyping scheme is that it should be present and discoverable in multiple datasets. We performed de novo clustering in \Sexpr{length(dataset.names)} independent ovarian datasets using the authors' original gene lists and clustering method. We compared these de novo cluster groupings to the labels from our implemented classifiers using the prediction strength statistic of Tibshirani and Walther, 2005.


In order to permit comparability between subtyping schemes, all datasets were filtered to patients with high-grade, late-stage, serous ovarian carcinomas.
%I performed clustering on 11 datasets from MetaGxOvarian:
%\Sexpr{dataset.names}

%Clustering was performed using a grid of 126 algorithm configurations:

%\vspace{10pt}

%\begin{tabular}{ | p{3cm} | p{3cm} |p{0.4cm} |} 
%\hline Algorithm & Gene Set & k \\ \hline 
%Consensus k-means NMF & TCGA gene set Tothill gene set Top 1000 by MAD Top 1500 by MAD Top 2000 by MAD Top 2500 by MAD Top 3000 by MAD & 2 3 4 5 6 7 8 9 10
%\\ \hline \end{tabular}

<<show_config_grid, results='asis', cache=FALSE, eval=FALSE>>=
config.grid.beginning <- head(config.grid, n=20)
config.grid.beginning$algorithm <- as.character(config.grid.beginning$algorithm)
config.grid.beginning$gene.set <- as.character(config.grid.beginning$gene.set)
config.grid.beginning <- rbind(config.grid.beginning, rep("...",3))
print(xtable(config.grid.beginning), include.rownames=FALSE)
@

\pagebreak
\subsection{Verhaak/TCGA}
Using the subtype labels from the implemented Verhaak classifier, compared against de novo clustering with NMF, k = 4, and the same gene list used by the authors:

<<stuff, eval=FALSE>>=
ps.val.matrix <- lapply(classifier.subtypes, function(subtype.predictions) {
  out <- sapply(1:nrow(config.grid), function(i) {
    sapply(1:length(subtype.predictions), function(x) ps.cluster(subtype.predictions[[x]], cluster.class.list[[i]][[x]])$ps)
  })
  rownames(out) <- names(subtype.predictions)
  return(out)
  })

config.grid.extended <- as.data.frame(lapply(config.grid, function(x) rep(x,each=nrow(ps.val.matrix[[1]]))))
df.for.regression <- data.frame(
  algorithm=config.grid.extended$algorithm, 
  gene.set=config.grid.extended$gene.set,
  dataset=melt(ps.val.matrix$Konecny)$Var1,
  ps.konecny=melt(ps.val.matrix$Konecny)$value,
  ps.verhaak=melt(ps.val.matrix$Verhaak)$value,
  ps.helland=melt(ps.val.matrix$Helland)$value)
@

<<TCGA_pred_str, out.width="0.7\\textwidth", cache=FALSE>>=
tcga.ps.vals <- sapply(1:length(classifier.subtypes$Verhaak), function(x) ps.cluster(classifier.subtypes$Verhaak[[x]], cluster.class.list[[which(config.grid$algorithm == "nmf" & config.grid$gene.set == "tcga" & config.grid$k == 4)]][[x]])$ps)
names(tcga.ps.vals) <- names(classifier.subtypes$Verhaak)
barplot(tcga.ps.vals, ylim=c(0,1), las=2, ylab="Prediction strength")
@
\pagebreak
Prediction strength vs the number of patients in each dataset:
<<TCGA_pred_str_scatter, out.width="0.7\\textwidth", cache=FALSE>>=

sample.sizes <- sapply(esets.rescaled.with.subtype[dataset.names], ncol)
plot(sample.sizes, tcga.ps.vals)
@
(Spearman's correlation = \Sexpr{cor(sample.sizes, tcga.ps.vals, method='spearman')})
\pagebreak
\subsection{Tothill/Helland}

Using the subtype labels from the implemented Tothill/Helland classifier, compared against de novo clustering with consensus k-means, k = 4, and the gene list used by the authors:\footnote{this gene list was obtained by closely replicating their filtering methods, and is probably pretty accurate since the clustering we did previously was very concordant}

<<Tothill_cluster_for_pred_str>>=

@

<<Tothill_pred_str, out.width="0.7\\textwidth", cache=FALSE>>=
tothill.ps.vals <- sapply(1:length(classifier.subtypes$Helland), function(x) ps.cluster(classifier.subtypes$Helland[[x]], cluster.class.list[[which(config.grid$algorithm == "kmeans" & config.grid$gene.set == "tothill" & config.grid$k == 4)]][[x]])$ps)
names(tothill.ps.vals) <- names(classifier.subtypes$Helland)
barplot(tothill.ps.vals, ylim=c(0,1), las=2, ylab="Prediction strength")
@
\pagebreak
Prediction strength vs the number of patients in each dataset:
<<Tothill_pred_str_scatter, out.width="0.7\\textwidth", cache=FALSE>>=
plot(sample.sizes, tothill.ps.vals)
@
(Spearman's correlation = \Sexpr{cor(sample.sizes, tothill.ps.vals, method='spearman')})

\pagebreak
\subsection{Konecny}
Using the subtype labels from the implemented Konecny classifier, compared against de novo clustering with consensus k-means, k = 4, and the gene list of the authors:
<<Konecny_pred_str, out.width="0.7\\textwidth", cache=FALSE>>=
konecny.ps.vals <- sapply(1:length(classifier.subtypes$Konecny), function(x) ps.cluster(classifier.subtypes$Konecny[[x]], cluster.class.list[[which(config.grid$algorithm == "nmf" & config.grid$gene.set == "2000" & config.grid$k == 4)]][[x]])$ps)
names(konecny.ps.vals) <- names(classifier.subtypes$Konecny)
barplot(konecny.ps.vals, ylim=c(0,1), las=2, ylab="Prediction strength")
@

\pagebreak
Prediction strength vs the number of patients in each dataset:
<<Konecny_pred_str_scatter, out.width="0.7\\textwidth", cache=FALSE>>=
plot(sample.sizes, konecny.ps.vals)
@
(Spearman's correlation = \Sexpr{cor(sample.sizes, tothill.ps.vals, method='spearman')})


<<dataset_barplot, cache=FALSE>>=

par(mar=c(5.1,10,4.1,2.1))
barplot(sapply(esets.rescaled.with.subtype[dataset.names], function(x) ncol(exprs(x))), horiz=TRUE, las=2, col="blue", main="HGS sample sizes")
par(mar=c(5.1, 4.1, 4.1, 2.1))
@
