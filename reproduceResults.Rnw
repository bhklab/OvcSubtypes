%\VignetteEngine{knitr::knitr}
\documentclass{article}

\usepackage{graphicx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage[table]{xcolor}
%\newcommand{\sectionbreak}{\clearpage}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# Set options
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, cache=TRUE)
options(replace.assign=TRUE,width=90)
par.original <- par()
days.per.month <- 30.4368
days.per.year <- 365.242
package.dir <- "~/repos/MetaGx/"
@

\title{Reproduction of Published Ovarian Subtyping Schemes}

\author{Gregory M. Chen}
\date{\today}
\maketitle

%\tableofcontents 

<<load, cache=FALSE>>=
library(gdata)
library(HiDimDA)
library(survival)
library(reshape2)
library(genefu)
library(annotate)
library(hgu133plus2.db)
# library(survMisc) 
library(xtable)
library(gridExtra)
library(Biobase)
library(GSVA)
library(sparsediscrim)
library(MetaGxOvarian)
library(survcomp)
library(ggplot2)
library(e1071)
library(randomForest)
@

<<load_data>>=
#
#source(system.file("extdata", "reproduce.results.patientselection.config", package="MetaGx2"))
#source(system.file("extdata", "patientselection.config", package="MetaGxOvarian"))

# Get the Tothill dataset with non-rescaled genes
source("../../inst/extdata/reproduce.results.patientselection.config")
### use this line if you do not want to get rid of duplicates
rm(remove.duplicates)
rm(probe.gene.mapping)
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))

getGeneMapping <- function(eset) {
  eset <- eset[fData(eset)$best_probe,]
  rownames(eset) <- paste0("geneid.", fData(eset)$EntrezGene.ID)
  return(eset)
}
@

This document reports the results of my initial implementations of ovarian cancer subtyping classification schemes described below. Using the gene lists provided in supplementary data for each publication, I have implemented the subtyping classifiers as described in the methods or supplementary texts, replicating their methods as closely as possible.
\tableofcontents

% Konecny et al., 2014
\pagebreak
\section{Konecny et al., 2014}
<<konecny, cache=FALSE>>=
source("../../R/getKonecnySubtypes.R", chdir=TRUE)
# validate on Bonome dataset
bonome.eset <- getGeneMapping(esets$GSE26712)

implemented.konecny.out <- getKonecnySubtypes(bonome.eset)
konecny.spreadsheet.data <- read.xls("../../inst/extdata/jnci_JNCI_14_0249_s06.xls")
# subtypes generated by our implementation
konecny.predicted.subtypes <- pData(implemented.konecny.out$Annotated.eset)[,"Konecny.subtypes",drop=FALSE]
rownames(konecny.predicted.subtypes) <- sub("GSE26712_", "", rownames(konecny.predicted.subtypes))

rownames(konecny.spreadsheet.data) <- konecny.spreadsheet.data$X

konecny.merged <- merge(konecny.predicted.subtypes, konecny.spreadsheet.data[,"Mayo_assgn_subtype_vec",drop=FALSE], by="row.names")
rownames(konecny.merged) <- konecny.merged$Row.names
konecny.merged <- konecny.merged[,-1]

konecny.merged$Konecny.subtypes <- as.factor(gsub("[^0-9]", "", konecny.merged$Konecny.subtypes))
konecny.merged$Mayo_assgn_subtype_vec <- as.factor(konecny.merged$Mayo_assgn_subtype_vec)
# Remove observations which the authors left unclassified
konecny.merged <- konecny.merged[complete.cases(konecny.merged),]
konecny.merged[] <- sapply(konecny.merged, function(x) {levels(x) <- paste0("c", levels(x)); as.factor(x)})
konecny.merged$Konecny.subtypes <- as.factor(konecny.merged$Konecny.subtypes)
konecny.merged$Mayo_assgn_subtype_vec <- as.factor(konecny.merged$Mayo_assgn_subtype_vec)
konecny.validation.accuracy <- round(mean(konecny.merged$Konecny.subtypes == konecny.merged$Mayo_assgn_subtype_vec) * 100, digits=2)
@

First, we implemented the subtyping classification scheme by Konecny et al., 2014. Their subtype classification scheme uses a nearest-centroids approach with Spearman's correlation coefficient as the distance measure. The authors provided a list of 635 selected probe sets for classifying new cases. To allow cross-platform applicability, we implemented the subtype classifier using the 575 unique Entrez gene IDs corresponding to these probe sets (with the mean value taken for multiple probe sets mapping to the same gene ID). In their supplementary materials, Konecny et al. report their predicted subtypes on a validation dataset (Bonome et al.). To assess our implementation, we compared our predicted subtypes on the Bonome dataset. The contingency matrix is given below, indicating a large degree of concordance between our implemented subtypes and the author's supplementary data. Overall, \Sexpr{konecny.validation.accuracy}\% of samples were classified identically between our implementation and the supplementary results.

<<konecny_table, results='asis'>>=
addtorow <- list()
addtorow$pos <- list()
addtorow$pos[[1]] <- 0
addtorow$pos[[2]] <- 0
addtorow$command <- c('& Konecny Subtypes from Supplementary & & &\\\\\n', "Implemented Konecny Subtypes & c1 & c2 & c3 & c4 \\\\\n")
print(xtable(as.table(ftable(konecny.merged)), caption="Contingency table showing strong concordance between using our implementation of the Konecny subtyping classifier and the predictions given in the supplementary materials of the Konecny manuscript. These predictions were made on the dataset of Bonome et al."), add.to.row=addtorow, include.colnames=FALSE)
@

We also generated survival curves for our implemented subtypes on the Bonome set. This plot resembles Figure 3A of the main text of Konecny et al.
\begin{figure}[H]
\centering
<<konecny_survival, fig.width=8, fig.height=4, out.width="0.6\\textwidth">>=
data.for.survival <- pData(implemented.konecny.out$Annotated.eset)[,c("days_to_death", "vital_status", "Konecny.subtypes")]
# Remove patients with missing survival information
data.for.survival <- data.for.survival[complete.cases(data.for.survival),]
data.for.survival$months_to_death <- data.for.survival$days_to_death / days.per.month
data.for.survival$vital_status <- data.for.survival$vital_status == "deceased"
surv.obj <- survfit(Surv(data.for.survival$months_to_death, data.for.survival$vital_status) ~ data.for.survival$Konecny.subtypes)
survMisc::autoplot(surv.obj, title="Survival curves", censSize=0)$plot + scale_colour_manual(name="Strata", values=c("black", "green", "blue", "red"))
@


<<konecny_survival_nbayes, fig.width=8, fig.height=4, out.width="0.6\\textwidth", eval=FALSE>>=
## TODO: when konecny expression set is available, complete this section
konecny.supplementary.data <- read.xls("../../inst/extdata/jnci_JNCI_14_0249_s05.xls", sheet=4)
konecny.entrez.ids <- konecny.supplementary.data$EntrezGeneID
@

\includegraphics[width=0.35\textwidth]{konecny_fig3A.png}
\caption{(Above) Survival curves the Bonome dataset using our implementation of the Konecny subtyping scheme. (Below) Corresponding Figure 3A from Konecny et al.}
\end{figure}

% Verhaak et al., 2013
\pagebreak
\section{Verhaak et al., 2013 / TCGA 2011}
<<verhaak, eval=TRUE>>=
source("../../R/getVerhaakSubtypes.R", chdir=TRUE)
verhaak.spreadsheet.data <- read.xls("../../inst/extdata/JCI65833sd1.xls", skip=1)
## Examine the correlation between normalized ssGSEA scores in the Tothill dataset, as predicted by our implementation and that of Verhaak et al.
verhaak.validation.esets <- list(Bonome=esets$GSE26712,
                                 #Crijns=esets$GSE13876, 
                                 Denkert=esets$GSE14764, 
                                 Dressman=esets$PMID17290060, 
                                 TCGA=esets$TCGA, # This contains the full TCGA set, but we will filter to the validation data later
                                 Tothill=esets$GSE9891, 
                                 Yoshihara=esets$GSE17260)

verhaak.validation.esets <- lapply(verhaak.validation.esets, getGeneMapping)
implemented.verhaak.output <- lapply(verhaak.validation.esets, getVerhaakSubtypes)



implemented.ssgsea.scores <- data.frame(Dataset.name=character(0), sample.name=character(0), DIF=numeric(0), IMR=numeric(0), MES=numeric(0), PRO=numeric(0), implemented.subtype=factor())

for(i in 1:length(implemented.verhaak.output)) {
  current.implemented.ssgsea.scores <- as.data.frame(implemented.verhaak.output[[i]][[2]])
  Dataset.name <- names(implemented.verhaak.output)[i]
  # Find the sample names corresponding to the names provided in the Verhaak et al. supplementary spreadsheet
  if(Dataset.name == "Bonome") {
    sample.name <- sub(".* ", "", pData(verhaak.validation.esets[[i]])$alt_sample_name)
  #} else if(Dataset.name == "Crijns") {
  #  sample.name <- as.character(pData(verhaak.validation.esets[[i]])$unique_patient_ID)
  } else if(Dataset.name == "Denkert") {
     sample.name <- sub("GSE14764_", "", rownames(pData(verhaak.validation.esets[[i]])))
  } else if(Dataset.name == "Dressman") {
    sample.name <- sub("PMID17290060_X", "", rownames(pData(verhaak.validation.esets[[i]])))
  } else if(Dataset.name == "TCGA") {
    sample.name <- as.character(pData(verhaak.validation.esets[[i]])$unique_patient_ID)
  }  else if(Dataset.name == "Tothill") {
    sample.name <- sub("GSE9891_", "", rownames(pData(verhaak.validation.esets[[i]])))
  }  else if(Dataset.name == "Yoshihara") {
    sample.name <- sub("GSE17260_", "", rownames(pData(verhaak.validation.esets[[i]])))
  }
  current.ssgsea.scores <- as.data.frame(implemented.verhaak.output[[i]][[2]])
  implemented.ssgsea.scores <- rbind(implemented.ssgsea.scores, data.frame(
                                                                      Dataset.name=Dataset.name,
                                                                      sample.name=sample.name,
                                                                      DIF=current.ssgsea.scores$DIF,
                                                                      IMR=current.ssgsea.scores$IMR,
                                                                      MES=current.ssgsea.scores$MES,
                                                                      PRO=current.ssgsea.scores$PRO,
                                                                      implemented.subtype=implemented.verhaak.output[[i]][[1]]$Verhaak.subtypes))
}

implemented.ssgsea.scores$Dataset.name <- as.character(implemented.ssgsea.scores$Dataset.name)
implemented.ssgsea.scores$Dataset.name[implemented.ssgsea.scores$Dataset.name == "TCGA"] <- "TCGA-validation"
implemented.ssgsea.scores$Dataset.name <- as.factor(implemented.ssgsea.scores$Dataset.name)

verhaak.spreadsheet.data.subset <- verhaak.spreadsheet.data[c(1,2,13,grep(".ssGSEA.normalized.score", colnames(verhaak.spreadsheet.data)))]
levels(implemented.ssgsea.scores$Dataset.name) <- toupper(levels(implemented.ssgsea.scores$Dataset.name))
levels(implemented.ssgsea.scores$sample.name) <- toupper(levels(implemented.ssgsea.scores$sample.name))
levels(verhaak.spreadsheet.data.subset$ID) <- toupper(levels(verhaak.spreadsheet.data.subset$ID))
levels(verhaak.spreadsheet.data.subset$DATASET) <- toupper(levels(verhaak.spreadsheet.data.subset$DATASET))

verhaak.spreadsheet.data.subset$CloverLeaf <- as.character(verhaak.spreadsheet.data.subset$CloverLeaf)
verhaak.spreadsheet.data.subset$CloverLeaf <- sub("_Good", "", as.character(verhaak.spreadsheet.data.subset$CloverLeaf))
verhaak.spreadsheet.data.subset$CloverLeaf <- sub("_Poor", "", as.character(verhaak.spreadsheet.data.subset$CloverLeaf))
verhaak.spreadsheet.data.subset$CloverLeaf <- as.factor(verhaak.spreadsheet.data.subset$CloverLeaf)

colnames(implemented.ssgsea.scores)[1:2] <- c("DATASET", "ID")

# subtypes predicted by our implementation

verhaak.merged <- merge(implemented.ssgsea.scores, verhaak.spreadsheet.data.subset, by=c("DATASET", "ID"))

# Plot correlations between ssGSEA scores

DIF.cor <- cor(verhaak.merged$DIF, verhaak.merged$Differentiated.ssGSEA.normalized.score)
IMR.cor <- cor(verhaak.merged$IMR, verhaak.merged$Immunoreactive.ssGSEA.normalized.score)
MES.cor <- cor(verhaak.merged$MES, verhaak.merged$Mesenchymal.ssGSEA.normalized.score)
PRO.cor <- cor(verhaak.merged$PRO, verhaak.merged$Proliferative.ssGSEA.normalized.score)

accuracy.classification.with.thresholds <- mean(verhaak.merged$implemented.subtype == verhaak.merged$CloverLeaf)
accuracy.classification.by.max <- mean(apply(verhaak.merged[,3:6],1,which.max) == apply(verhaak.merged[,9:12],1,which.max))
@

Next, we implemented the subtype classification scheme given by Verhaak et al., 2013. The authors designed a classifier based on single-sample GSEA to classify samples into subtypes previously defined in TCGA, 2011. In their supplementary materials, the authors provide a list of four sets of gene symbols (100 total gene symbols), with each gene set associated with a subtype. 

We implemented this subtype classification scheme using the provided gene sets and the ssGSEA implementation in \texttt{R} package \texttt{GSVA}. The parameters to the function \texttt{gsva} were: \texttt{method="ssgsea"}, \texttt{min.sz=10}, \texttt{tau=0.75}, which resemble default GenePattern parameters.\footnote{These parameters differ slightly from the function call used in Waldron et al. (2014)}

To compare our implementation, we compared our normalized ssGSEA scores with the scores in the validation set used in the original study. In their supplementary materials, Verhaak et al. provide their normalized ssGSEA scores for a validation set consisting of the datasets of Bonome, Crijns, Denkert, Dressman, Tothill, Yoshihara, and a subset of TCGA. This validation dataset consisted of \Sexpr{nrow(verhaak.spreadsheet.data[ !is.na(verhaak.spreadsheet.data$CloverLeaf) & verhaak.spreadsheet.data$DATASET != "CRIJNS",])} patients reported in their supplementary;\footnote{These numbers exclude the dataset of Crijns et al., as the patient IDs in the supplementary did not match the IDs in MetaGxOvarian.} we matched \Sexpr{nrow(verhaak.merged)} patients from MetaGxOvarian data. 

Due to different normalization methods, our ssGSEA scores differ in numeric range but are expected to correlate strongly with the values provided in the supplementary materials. of the \Sexpr{nrow(verhaak.spreadsheet.data[!is.na(verhaak.spreadsheet.data$CloverLeaf),])} patients in the supplementary material, \Sexpr{nrow(verhaak.merged)} were matched. We observed Pearson's correlation coefficients of \Sexpr{round(DIF.cor, digits=2)}, \Sexpr{round(IMR.cor, digits=2)}, \Sexpr{round(MES.cor, digits=2)}, and \Sexpr{round(PRO.cor, digits=2)} for subtypes DIF, IMR, MES, and PRO respectively. 

\begin{figure}[H]
<<verhaak_figures, eval=TRUE, fig.width=10, fig.height=8, out.width="0.9\\textwidth">>=
par(mfrow=c(2,2))
par(oma=c(0,0,0,11))
verhaak.dataset.cols <- RColorBrewer::brewer.pal(length(levels(verhaak.merged$DATASET)), name="Dark2")[as.integer(verhaak.merged$DATASET)]
plot(verhaak.merged$DIF, verhaak.merged$Differentiated.ssGSEA.normalized.score, col=verhaak.dataset.cols, xlab="Implemented DIF ssGSEA", ylab="Published DIF ssGSEA Score")
plot(verhaak.merged$IMR, verhaak.merged$Immunoreactive.ssGSEA.normalized.score, col=verhaak.dataset.cols, xlab="Implemented IMR ssGSEA", ylab="Published IMR ssGSEA Score")
plot(verhaak.merged$MES, verhaak.merged$Mesenchymal.ssGSEA.normalized.score, col=verhaak.dataset.cols, xlab="Implemented MES ssGSEA", ylab="Published MES ssGSEA Score")
plot(verhaak.merged$PRO, verhaak.merged$Proliferative.ssGSEA.normalized.score, col=verhaak.dataset.cols, xlab="Implemented PRO ssGSEA", ylab="Published PRO ssGSEA Score")
par(usr=c(0,1,0,1), # Reset the coordinates
          xpd=NA)
legend(1.1,2.61, 
       inset = 0,
       legend=levels(verhaak.merged$DATASET),
       col=RColorBrewer::brewer.pal(length(levels(verhaak.merged$DATASET)), name="Dark2"),
       pch=1)
par(par.original)
@
\caption{ssGSEA scores for the >700 patient validation set from our implementation (x axis) and the supplementary material (y axis) for each of the four subtypes.}
\end{figure}

From these normalized ssGSEA scores, a subtype classification may be performed according to one of two procedures. The first is described by Verhaak et al. and involves first classifying Immunoreactive and Mesenchymal subtypes by the higher score if corresponding ssGSEA scores exceed a given threshold.\footnote{The authors obtained their thresholds as the lowest ssGSEA scores for samples clustered within Immunoreactive and Mesenchymal subtypes respectively. For our implementation, we used the same TCGA train data with original cluster labels to re-compute these threshold values for each gene list used for classifying new samples.} Overall, this method produces a concordance of \Sexpr{round(100 * accuracy.classification.with.thresholds, digits=2)}\% of samples classified identically between our implementation and supplementary results.

<<verhaak_table_bythreshold, results='asis'>>=
implemented.classes.from.threshold <-  verhaak.merged$implemented.subtype
supplementary.classes.from.threshold <- verhaak.merged$CloverLeaf
addtorow <- list()
addtorow$pos <- list()
addtorow$pos[[1]] <- 0
addtorow$pos[[2]] <- 0
addtorow$command <- c('& Verhaak Subtypes from Supplementary & & &\\\\\n', "Implemented Verhaak Subtypes & DIF & IMR & MES & PRO \\\\\n")
print(xtable(table(implemented.classes.from.threshold, supplementary.classes.from.threshold), caption="Contingency table showing concordance using our implementation of the Verhaak subtyping classifier and the predictions given in the supplementary of the Verhaak manuscript, using threshold values for Immunoreactive and Mesenchymal subtypes. The predictions for both implementations were made on the combined >700 sample dataset by taking the max ssGSEA subtype score."), add.to.row=addtorow, include.colnames=FALSE)
@

The second method is to directly assign the subtype by the max ssGSEA score. Overall, this method produces a concordance of \Sexpr{round(100 * accuracy.classification.by.max, digits=2)}\% of samples classified identicially between our implementation and supplementary results.

<<verhaak_table_bymax, results='asis'>>=
implemented.classes.from.max <-  as.factor(c("DIF", "IMR", "MES", "PRO")[apply(verhaak.merged[,c("DIF", "IMR", "MES", "PRO")],1,which.max)]) 
supplementary.classes.from.max <- as.factor(c("DIF", "IMR", "MES", "PRO")[apply(verhaak.merged[,paste0(c("Differentiated", "Immunoreactive", "Mesenchymal", "Proliferative"), ".ssGSEA.normalized.score")],1,which.max)])
addtorow <- list()
addtorow$pos <- list()
addtorow$pos[[1]] <- 0
addtorow$pos[[2]] <- 0
addtorow$command <- c('& Verhaak Subtypes from Supplementary & & &\\\\\n', "Implemented Verhaak Subtypes & DIF & IMR & MES & PRO  \\\\\n")
print(xtable(table(implemented.classes.from.max, supplementary.classes.from.max), caption="Contingency table showing concordance using our implementation of the Verhaak subtyping classifier and the predictions given in the supplementary of the Verhaak manuscript, using the max ssGSEA score for each class. The predictions for both implementations were made on the combined >700 sample dataset by taking the max ssGSEA subtype score."), add.to.row=addtorow, include.colnames=FALSE)
@

<<verhaak_classifiers, out.width="0.6\\textwidth">>=
# Get the labels from the original publication clustering algorithm
verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE")]
colnames(verhaak.labels.table)[2] <- "clustering_subtype"
levels(verhaak.labels.table[,2]) <- sub("Immunoreactive", "IMR",levels(verhaak.labels.table[,2]))
levels(verhaak.labels.table[,2]) <- sub("Proliferative", "PRO",levels(verhaak.labels.table[,2]))
levels(verhaak.labels.table[,2]) <- sub("Differentiated", "DIF",levels(verhaak.labels.table[,2]))
levels(verhaak.labels.table[,2]) <- sub("Mesenchymal", "MES",levels(verhaak.labels.table[,2]))

intersecting.verhaak.tcga.ids <- intersect(verhaak.labels.table$ID, esets$TCGA$unique_patient_ID)

verhaak.labels.table <- verhaak.labels.table[verhaak.labels.table$ID %in% intersecting.verhaak.tcga.ids,]

tcga.discovery.eset <- getGeneMapping(esets$TCGA[,match(verhaak.labels.table$ID, esets$TCGA$unique_patient_ID)])

implemented.verhaak.output.subtypes <- getVerhaakSubtypes(tcga.discovery.eset)$Annotated.eset$Verhaak.subtypes

verhaak.supplementary.data.sheet7 <- read.xls("../../inst/extdata/JCI65833sd1.xls", sheet=7, skip=1)
verhaak.gene.names <- verhaak.supplementary.data.sheet7$Gene.Symbol
# populate verhaak.train.data with expression data. Rows are samples, columns are genes.
verhaak.train.data <- t(exprs(tcga.discovery.eset))
verhaak.train.data <- as.data.frame(verhaak.train.data)
intersecting.verhaak.tcga.ids <- intersect(verhaak.labels.table$ID, esets$TCGA$unique_patient_ID)
verhaak.labels.table <- verhaak.labels.table[verhaak.labels.table$ID %in% intersecting.verhaak.tcga.ids,]
verhaak.train.data <- verhaak.train.data[,fData(tcga.discovery.eset)$gene %in% verhaak.gene.names]
verhaak.train.data$clustering_subtype <- verhaak.labels.table$clustering_subtype

set.seed(150)

.getBootstrapAccuracyVals <- function(formula, data, train.function, custom.predict.function = NULL, num.repetitions=1000) {
  bootstrap.accuracy.vals <- lapply(1:num.repetitions, function(x) {
    num.samples <- nrow(data)
    indices.to.include <- sample(1:num.samples, size = num.samples, replace=TRUE)
    indices.out.of.bootstrap <- setdiff(1:num.samples, indices.to.include)
    current.train.data <- data[indices.to.include,]
    current.test.data <- data[indices.out.of.bootstrap,]
    trained.model <- train.function(formula, data=current.train.data)
    response.var.name <- all.vars(formula)[1]
    if(is.null(custom.predict.function)) {
      current.predictions <- predict(trained.model, newdata=current.test.data[,-which(colnames(current.test.data) == response.var.name)])
    } else {
      current.predictions <- custom.predict.function(trained.model, newdata=current.test.data[,-which(colnames(current.test.data) == response.var.name)])
    }
    current.accuracy <- mean(current.predictions == current.test.data$clustering_subtype)
    return(current.accuracy)
    })#, mc.cores = parallel::detectCores())
  return(unlist(bootstrap.accuracy.vals))
}
.getCrossValidationAccuracyVals <- function(formula, data, train.function, custom.predict.function = NULL, num.folds=10) {
  num.samples <- nrow(data)
  folds <- as.factor(rep(1:num.folds, size=num.samples))
  cv.accuracy.vals <- lapply(levels(folds), function(current.fold) {
    current.train.data <- data[folds != current.fold,]
    current.test.data <- data[folds == current.fold,]
    trained.model <- train.function(formula, data=current.train.data)
    response.var.name <- all.vars(formula)[1]
    if(is.null(custom.predict.function)) {
      current.predictions <- predict(trained.model, newdata=current.test.data[,-which(colnames(current.test.data) == response.var.name)])
    } else {
      current.predictions <- custom.predict.function(trained.model, newdata=current.test.data[,-which(colnames(current.test.data) == response.var.name)])
    }
    current.accuracy <- mean(current.predictions == current.test.data$clustering_subtype)
    return(current.accuracy)
    })#, mc.cores = parallel::detectCores())
  return(unlist(cv.accuracy.vals))
}

num.folds <- 10

verhaak.cv.accuracy.vals.nb <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = verhaak.train.data, train.function = e1071::naiveBayes, num.folds=num.folds)
verhaak.cv.accuracy.vals.rf <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = verhaak.train.data, train.function = randomForest::randomForest, num.folds=num.folds)
verhaak.cv.accuracy.vals.svm <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = verhaak.train.data, train.function = e1071::svm, num.folds=num.folds)
verhaak.cv.accuracy.vals.dlda <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = verhaak.train.data, train.function = sparsediscrim::dlda, custom.predict.function = function(object, newdata) predict(object, newdata)[[1]], num.folds=num.folds)

verhaak.cvplot.data.m <- data.frame(
  Algorithm=c("NaiveBayes", "RandomForest", "SVM", "DLDA"),
  Accuracy = c(mean(verhaak.cv.accuracy.vals.nb), mean(verhaak.cv.accuracy.vals.rf), mean(verhaak.cv.accuracy.vals.svm), mean(verhaak.cv.accuracy.vals.dlda)),
  ci.width = c(sd(verhaak.cv.accuracy.vals.nb), sd(verhaak.cv.accuracy.vals.rf), sd(verhaak.cv.accuracy.vals.svm), sd(verhaak.cv.accuracy.vals.dlda))
)
# 95% CI
verhaak.cvplot.data.m$ci.width <- qnorm(0.975) * verhaak.cvplot.data.m$ci.width

implemented.verhaak.accuracy <- mean(implemented.verhaak.output.subtypes == verhaak.train.data$clustering_subtype)
@

<<verhaak_boxplot_plotting>>=
ggplot(verhaak.cvplot.data.m, aes(Algorithm, Accuracy)) + geom_point() + geom_errorbar(aes(ymin=Accuracy-ci.width, ymax=Accuracy+ci.width), width=0.1) + geom_hline(aes(yintercept=implemented.verhaak.accuracy)) + scale_y_continuous(limits=c(0,1.05)) + ggtitle("Verhaak Classifiers")
@


<<verhaak_survival>>=
verhaak.nb.classes <- lapply(verhaak.validation.esets, function(eset) {
  intersecting.genes <- intersect(colnames(verhaak.train.data), rownames(fData(eset)))
  current.train.data <- verhaak.train.data[,colnames(verhaak.train.data) %in% intersecting.genes]
  verhaak.nb.model <- e1071::naiveBayes(clustering_subtype ~ ., data=verhaak.train.data)
  current.test.data <- t(exprs(eset))
  current.test.data <- as.data.frame(current.test.data)
  current.test.data <- current.test.data[,rownames(fData(eset)) %in% intersecting.genes]
  predicted.classes <- predict(verhaak.nb.model, current.test.data)
  out.df <- cbind(pData(eset)[,c("days_to_death", "vital_status")], predicted.classes)
  colnames(out.df)[ncol(out.df)] <- "NB.subtype"
  out.df$NB.subtype <- as.character(out.df$NB.subtype)
  return(out.df)
})

for(name in names(verhaak.nb.classes)) {
  verhaak.nb.classes[[name]]$data.source <- name
}

# Classify on validation datasets
verhaak.nb.survival.df <- do.call(rbind, verhaak.nb.classes)
surv.obj <- survfit(Surv(verhaak.nb.survival.df$days_to_death, verhaak.nb.survival.df$vital_status == "deceased") ~ verhaak.nb.survival.df$NB.subtype)
survMisc::autoplot(surv.obj, title="Survival curves", censSize=0)$plot + scale_colour_manual(name="Strata", values=c("black", "green", "blue", "red"))
@

%<<tothill>>=
%source("../../R/getTothillSubtypes.R", chdir=TRUE)
%dressman.eset <- esets$PMID17290060
%implemented.tothill.out <- getTothillSubtypes(dressman.eset, gene.mapping="Probe.ID")

%subtype.counts <- as.data.frame(table(pData(implemented.tothill.out[[1]])$Tothill.subtypes))
%colnames(subtype.counts) <- c("Subtype", "Our.Implementation")
%# From the main text of the paper
%published.validation.counts <- c(C1=40, C2=24, C3=5, C4=36, C5=14, C6=0)
%subtype.counts$Published.Validation.Counts = published.validation.counts[match(subtype.counts$Subtype, names(published.validation.counts))]

%subtype.counts.m <- melt(subtype.counts)
%colnames(subtype.counts.m) <- c("Subtype", "Implementation", "Count")
%@
%\pagebreak
%\section{Tothill et al., 2008}

%Next, we implemented the subtype classifier of Tothill et al., 2008. The authors classified samples in their validation set (Dressman et al.) using a diagonal linear discriminant analysis (DLDA) classifier trained on a selected set of probe sets common to the Affymetrix U113Plus2 and U113A.\footnote{Tothill et al. filtered their probes by variance to 8732 U113Plus2 probe sets which they used for clustering. To the best of my knowledge, they do not report these 8732 probe sets in their text or supplementary. In their Supplementary Table 2, they report the 4372 probe sets and 2857 unique Entrez IDs which overlap with the U133A; they used the probe sets to classify the Dressman data set. My implementation allows the user to specify whether they would like to classify by probe set or Entrez ID; to generate the data for this section, I used the intersection of Entrez IDs in the supplementary and the Dressman/Tothill datasets, which yielded 2095 Entrez IDs.}

%Below is a bar plot showing the counts of each predicted subtype by our implementation and published results, classified on the Dressman dataset.\footnote{To my knowledge, Tothill et al. do not provide their classifier's labels for each sample, so I was unable to generate a contingency table.}

%\begin{figure}[H]
%\centering
%<<tothill_barplot, fig.width=10, fig.height=2, out.width="0.75\\textwidth">>=
%# reverse the levels of Implementation to swap the positions of the barplot
%subtype.counts.m$Implementation <- factor(subtype.counts.m$Implementation, levels=rev(levels(subtype.counts.m$Implementation)))
%ggplot(subtype.counts.m, aes(x=Implementation, y=Count, fill=Subtype)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(size=6)) + coord_flip()
%@
%\caption{Stacked bar plot indicating class distributions of predicted subtypes on the Dressman dataset using data from our implementation of the Tothill scheme (top) and the main text of the Tothill manuscript (bottom).}
%\end{figure}

%\begin{figure}[H]
%\centering
%<<tothill_survival, fig.width=8, fig.height=4.5, out.width="0.5\\textwidth">>=
%# Create survival curves
%data.for.survival <- pData(implemented.tothill.out$Annotated.eset)[,c("days_to_death", "vital_status", "Tothill.subtypes")]
%data.for.survival$vital_status <- data.for.survival$vital_status == "deceased"
%# To match the figure in the main text, set a cutoff of 60 months (1826 days). Set patients surviving longer than
%# 1826 to vital status FALSE (still alive), survival = 1826.
%#data.for.survival[ data.for.survival$days_to_death > 1826,]$vital_status <- FALSE
%#data.for.survival[ data.for.survival$days_to_death > 1826,]$days_to_death <- 1826
%data.for.survival$months_to_death <- data.for.survival$days_to_death / days.per.month
%data.for.survival$days_to_death <- NULL

%censored.out <- survcomp::censor.time(data.for.survival$months_to_death, data.for.survival$vital_status, time.cens=60)

%data.for.survival$months_to_death <- censored.out$surv.time.cens
%data.for.survival$vital_status <- censored.out$surv.event.cens

%surv.obj <- survfit(Surv(data.for.survival$months_to_death, data.for.survival$vital_status) ~ data.for.survival$Tothill.subtypes)
%survMisc::autoplot(surv.obj, title="Survival curves", censSize=0)$plot + scale_colour_manual(name="Strata", values=c("black", "red", "green", "blue", "#58C0FF"))
%@
%\includegraphics[width=0.35\textwidth]{tothill_fig5D.png}
%\caption{(Above) Survival curves the Dressman dataset using our implementation of the Tothill subtyping scheme. (Below) Corresponding Figure 5D from Tothill et al. Note the difference in scale on the x axis - both axes are in months, but MetaGxOvarian has extended survival information.}
%\end{figure}

<<helland>>=
source("../../R/getHellandSubtypes.R", chdir=TRUE)
tcga.eset <- getGeneMapping(esets$TCGA)
implemented.helland.out <- getHellandSubtypes(tcga.eset)
# Labelled validation data, provided by the authors by email
helland.labelled.validation <- read.csv("../../inst/extdata/TCGA_samples_classified.csv")
helland.labelled.validation <- helland.labelled.validation[,c("SAMPLEID", "ClassLabel")]
colnames(helland.labelled.validation) <- c("unique_patient_ID", "ClassLabel")
helland.merged <- merge(pData(implemented.helland.out[[1]]), helland.labelled.validation, by="unique_patient_ID")
##TODO: investigate why the following TCGA unique patient IDs are not in MetaGxOvarian: TCGA-01-0628 TCGA-01-0630 TCGA-01-0631 TCGA-01-0633 TCGA-01-0636 TCGA-01-0637 TCGA-01-0639 TCGA-01-0642 TCGA-13-0760 TCGA-24-0981
helland.accuracy <- mean(helland.merged$Helland.subtypes == helland.merged$ClassLabel)
@
\pagebreak
\section{Helland et al., 2011 / Tothill et al., 2008}
Next, we implemented the subtype classifier of Helland et al., 2011. The same group as the Tothill et al. study implemented a different classifier for their previously-described subtypes. They identified a gene list for each of their four previously-defined high-grade serous ovarian carcinoma subtypes. Using a method described in another study for breast cancer classification (Lim et al., Nat. Med. 2009), they trained a set of weights for each gene list. Classification was performed by taking a linear combination of weights and expression levels for each gene list, normalizing the scores, and classifying according to the highest-scoring subtype.

Using their published gene list and weights from the supplementary text,\footnote{The supplementary text consists of gene symbols, Affymetrix U133 Plus 2.0 Probe IDs, and weights. In order to associate these values to a unique Entrez ID, I did the following: using Bioconductor package \texttt{annotate} and data package \texttt{hgu133plus2.db}, identify each Entrez ID based on probe ID and platform alone. Out of 1164 probe IDs in the supplementary, 1132 mapped to a unique Entrez ID, 27 mapped to multiple Entrez IDs, and 5 did not map to an Entrez ID. For the 27 genes that mapped to multiple Entrez IDs, 25 were associated to a unique Entrez ID based on the gene symbol listed in the supplementary.}. we implemented their subtype classifier and applied it to the TCGA dataset. The authors kindly provided a spreadsheet listing their classifier's labels on the TCGA dataset.  Overall, \Sexpr{round(100 * helland.accuracy, digits=2)}\% of samples were classified identically between the authors' implementation and ours.

<<helland_table, results='asis'>>=
addtorow <- list()
addtorow$pos <- list()
addtorow$pos[[1]] <- 0
addtorow$pos[[2]] <- 0
addtorow$command <- c('& Original Helland Subtypes & & &\\\\\n', "Implemented Helland Subtypes & C1 & C2 & C4 & C5 \\\\\n")
print(xtable(table(helland.merged$Helland.subtypes, helland.merged$ClassLabel), caption="Contingency table showing concordance of our implementation and and the predictions given by the table provided by Helland et al. Predictions were made on the TCGA dataset. Note that subtypes C3 and C6 were excluded in the original study since they are associated with non-HGS ovarian tumours."), add.to.row=addtorow, include.colnames=FALSE)
@


\begin{figure}[H]
\centering
<<helland_survival, fig.width=8, fig.height=3, out.width="0.7\\textwidth">>=
helland.data.for.survival <- pData(implemented.helland.out$Annotated.eset)[,c("unique_patient_ID", "days_to_death", "vital_status", "Helland.subtypes")]
helland.data.for.survival <- helland.data.for.survival[helland.data.for.survival$unique_patient_ID %in% helland.labelled.validation$unique_patient_ID,]
# Remove patients with missing survival information
helland.data.for.survival <- helland.data.for.survival[complete.cases(helland.data.for.survival),]
helland.data.for.survival$months_to_death <- helland.data.for.survival$days_to_death / days.per.month
helland.data.for.survival$days_to_death <- NULL
helland.data.for.survival$vital_status <- helland.data.for.survival$vital_status == "deceased"
helland.censored.out <- survcomp::censor.time(helland.data.for.survival$months_to_death, helland.data.for.survival$vital_status, time.cens=130)
helland.data.for.survival$months_to_death <- helland.censored.out$surv.time.cens
helland.data.for.survival$vital_status <- helland.censored.out$surv.event.cens

surv.obj <- survfit(Surv(helland.data.for.survival$months_to_death, helland.data.for.survival$vital_status) ~ helland.data.for.survival$Helland.subtypes)
survMisc::autoplot(surv.obj, title="Survival curves", censSize=0)$plot + scale_colour_manual(name="Strata", values=c("black", "red", "green", "blue")) + scale_x_continuous(breaks=seq(0,120, 20))
@
\includegraphics[width=0.5\textwidth]{helland_fig1B_TCGA.png}
\caption{(Above) Survival curves the TCGA dataset using our implementation of the Helland subtyping scheme. (Below) Corresponding survival plot from Figure 1B from Helland et al.}
\end{figure}

<<helland_classifiers>>=
tothill.supptable1 <- read.xls("../../inst/extdata/Supplementary Table 1.xls")
tothill.labels.table <- tothill.supptable1[,c(1,2)]
colnames(tothill.labels.table) <- c("ID", "clustering_subtype")

tothill.labels.table$clustering_subtype <- as.character(tothill.labels.table$clustering_subtype)
tothill.labels.table <- tothill.labels.table[!(tothill.labels.table$clustering_subtype %in% c("NC", "3", "6")),]
tothill.labels.table$clustering_subtype <- sub("^", "C", tothill.labels.table$clustering_subtype)

tothill.train.eset <- getGeneMapping(esets$GSE9891[,match(tothill.labels.table$ID, sub("X", "", as.character(esets$GSE9891$alt_sample_name)))])

implemented.helland.output.subtypes <- getHellandSubtypes(tothill.train.eset)$Annotated.eset$Helland.subtypes

supplementary.type.1 <- read.xls("../../inst/extdata/journal.pone.0018064.s015.XLS", sheet=1)
supplementary.type.2 <- read.xls("../../inst/extdata/journal.pone.0018064.s015.XLS", sheet=2)
supplementary.type.4 <- read.xls("../../inst/extdata/journal.pone.0018064.s015.XLS", sheet=3)
supplementary.type.5 <- read.xls("../../inst/extdata/journal.pone.0018064.s015.XLS", sheet=4)
supplementary.tables <- list(C1=supplementary.type.1, C2=supplementary.type.2, C4=supplementary.type.4, C5=supplementary.type.5)

entrez.id.logFC.list <- lapply(supplementary.tables, function(x) {
  ## Use the supplementary table's listed probe id and gene name to determine the Entrez ID
  # If there is only one EntrezID that maps to a probe in hgu133plus2.db, use that Entrez ID.
  # If there are multiple EntrezIDs that map to a probe, then use the EntrezID (if any) that corresponds to the provided gene symbol.
  current.mapping <- suppressWarnings(select(hgu133plus2.db, as.character(x$ID), c("ENTREZID", "SYMBOL")))
  current.mapping <- current.mapping[ !is.na(current.mapping$ENTREZID), ]
  colnames(x)[1:2] <- c("PROBEID", "SYMBOL")
  mappings.with.unique.probeid <- current.mapping[ !(current.mapping$PROBEID %in% current.mapping$PROBEID[duplicated(current.mapping$PROBEID)]),]
  mappings.with.duplicate.probeid <- current.mapping[ current.mapping$PROBEID %in% current.mapping$PROBEID[duplicated(current.mapping$PROBEID)],]
  mappings.with.duplicate.probeid <- merge(x, mappings.with.duplicate.probeid, by=c("PROBEID", "SYMBOL"))[, c("PROBEID", "ENTREZID", "SYMBOL")]
  mappings.with.duplicate.probeid <- unique(mappings.with.duplicate.probeid)
  current.mapping <- rbind(mappings.with.unique.probeid, mappings.with.duplicate.probeid)
  to.return <- merge(x, current.mapping, by="PROBEID")[, c("ENTREZID", "PROBEID", "logFC")]
  return(to.return)
  })
  
helland.entrez.ids <- Reduce(function(x,y) union(x, y), lapply(entrez.id.logFC.list, function (x) x$ENTREZID))

helland.train.data <- t(exprs(tothill.train.eset))
helland.train.data <- as.data.frame(helland.train.data[,fData(tothill.train.eset)$EntrezGene.ID %in% helland.entrez.ids])

helland.train.data$clustering_subtype <- tothill.labels.table$clustering_subtype
helland.train.data$clustering_subtype <- as.factor(helland.train.data$clustering_subtype)

set.seed(150)

num.folds <- 10

helland.cv.accuracy.vals.nb <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = helland.train.data, train.function = e1071::naiveBayes, num.folds=num.folds)
helland.cv.accuracy.vals.rf <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = helland.train.data, train.function = randomForest::randomForest, num.folds=num.folds)
helland.cv.accuracy.vals.svm <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = helland.train.data, train.function = e1071::svm, num.folds=num.folds)
helland.cv.accuracy.vals.dlda <- .getCrossValidationAccuracyVals(clustering_subtype ~ ., data = helland.train.data, train.function = sparsediscrim::dlda, custom.predict.function = function(object, newdata) predict(object, newdata)[[1]], num.folds=num.folds)

helland.cvplot.data.m <- data.frame(
  Algorithm=c("NaiveBayes", "RandomForest", "SVM", "DLDA"),
  Accuracy = c(mean(helland.cv.accuracy.vals.nb), mean(helland.cv.accuracy.vals.rf), mean(helland.cv.accuracy.vals.svm), mean(helland.cv.accuracy.vals.dlda)),
  ci.width = c(sd(helland.cv.accuracy.vals.nb), sd(helland.cv.accuracy.vals.rf), sd(helland.cv.accuracy.vals.svm), sd(helland.cv.accuracy.vals.dlda))
)
# 95% CI
helland.cvplot.data.m$ci.width <- qnorm(0.975) * helland.cvplot.data.m$ci.width

implemented.helland.accuracy <- mean(implemented.helland.output.subtypes == helland.train.data$clustering_subtype)
@

<<helland_boxplot_plotting>>=
ggplot(helland.cvplot.data.m, aes(Algorithm, Accuracy)) + geom_point() + geom_errorbar(aes(ymin=Accuracy-ci.width, ymax=Accuracy+ci.width), width=0.1) + geom_hline(aes(yintercept=implemented.helland.accuracy)) + scale_y_continuous(limits=c(0,1.05)) + ggtitle("Helland Classifiers")
@

\pagebreak
\section{Bentink, Haibe-Kains et al., 2012}

<<bentink_crijns, fig.width=9, fig.height=4, cache=FALSE>>=
source("../../R/getBentinkSubtypes.R", chdir=TRUE)
crijns.eset <- getGeneMapping(esets$GSE13876)
tothill.eset <- getGeneMapping(esets$GSE9891)
dressman.eset <- getGeneMapping(esets$PMID17290060)
bentink.eset <- getGeneMapping(esets$E.MTAB.386)
denkert.eset <- getGeneMapping(esets$GSE14764)
mok.eset <- getGeneMapping(esets$GSE18520)

implemented.bentink.esets <- list(
  crijns=crijns.eset,
  tothill=tothill.eset,
  dressman=dressman.eset,
  bentink=bentink.eset,
  denkert=denkert.eset,
  mok=mok.eset)

implemented.bentink.esets <- lapply(implemented.bentink.esets, function(x) {
  x <- x[,x$histological_type=="ser" & x$summarygrade=="high" & x$summarystage=="late" & !is.na(x$histological_type) & !is.na(x$summarygrade) & !is.na(x$summarystage)]
  x <- x[,!is.na(x$days_to_death) & !is.na(x$vital_status)]
})

implemented.bentink.out <- lapply(implemented.bentink.esets, getBentinkSubtypes)

bentink.plots <- lapply(names(implemented.bentink.out), function(dataset.name) {
  data.to.plot <- pData(implemented.bentink.out[[dataset.name]]$Annotated.eset)
  data.to.plot <- merge(data.to.plot, data.frame(score=implemented.bentink.out[[dataset.name]]$angio$score), by='row.names')
  # only keep patients with high grade, late stage, serous ovarian carcinoma
  data.to.plot <- data.to.plot[,c("days_to_death", "vital_status", "Bentink.subtypes", "score")]
  data.to.plot$vital_status <- data.to.plot$vital_status=="deceased"
  # Consider survival up to ten years
  #if(sum(data.to.plot$days_to_death > 3652) > 0) {
  #  data.to.plot[ data.to.plot$days_to_death > 3652,]$vital_status <- FALSE
  #  data.to.plot[ data.to.plot$days_to_death > 3652,]$days_to_death <- 3652
  #}
  data.to.plot$years_to_death <- data.to.plot$days_to_death / days.per.year
  data.to.plot$days_to_death <- NULL
  censored.out <- survcomp::censor.time(data.to.plot$years_to_death, data.to.plot$vital_status, time.cens=10)
  data.to.plot$years_to_death <- censored.out$surv.time.cens
  data.to.plot$vital_status <- censored.out$surv.event.cens
  
  surv.obj <- survfit(Surv(data.to.plot$years_to_death, data.to.plot$vital_status) ~ data.to.plot$Bentink.subtypes)
  
  density.plot <- ggplot(data.to.plot, aes(x=score, colour=Bentink.subtypes)) + theme_bw() + scale_colour_manual(name="Bentink.subtypes", values=c("#E6E600", "darkblue")) + geom_density(size=1) + theme(legend.position="bottom", legend.direction='vertical') 
  survival.plot <- survMisc::autoplot(surv.obj, title="Survival curves", censSize=0)$plot + theme_bw() + theme(legend.position="bottom", legend.direction='vertical') + scale_colour_manual(name="Strata", values=c("#E6E600", "darkblue")) 
  #p <- grid.arrange(density.plot, survival.plot, ncol=2)                 
  return(list(density.plot, survival.plot, data.to.plot))
})

names(bentink.plots) <- names(implemented.bentink.out)

@

  We implemented the subtype classifier of Bentink, Haibe-Kains et al. (2012) using the function \texttt{genefu::ovcAngiogenic}, which assigned one of two subtypes based on weights of a DLDA classifier. The authors classified samples in ten independent datasets, and provide survival curves and a distribution of scores. Below are score distribution and survival plots from our implementation, using data from high-grade, late-stage serous ovarian carcinoma. Note that the distribution plots that we generated are non-parametric density estimates, whereas the distributions from the supplementary manuscript are fitted curves to normal distributions.

\subsection*{Validation: Tothill dataset}
Our implementation of the Bentink et al. subtype classifier on the Tothill et al. dataset classified \Sexpr{sum(bentink.plots[["tothill"]][[3]]$Bentink.subtypes=="Angiogenic")} patients as `angiogenic' and \Sexpr{sum(bentink.plots[["tothill"]][[3]]$Bentink.subtypes=="nonAngiogenic")} as `non-angiogenic'.\footnote{The counts and plots are similar, but not identical. Perhaps this is due to differences in gene expression normalization?}

\begin{figure}[H]
{\centering
<<bentink_tothill_survival, fig.width=9, fig.height=5, out.width="0.75\\textwidth", cache=FALSE>>=
grid.arrange(bentink.plots[["tothill"]][[1]], bentink.plots[["tothill"]][[2]], ncol=2)
@
}
\includegraphics[width=\textwidth]{bentink_supp2_tothill.png}
\caption{Tothill dataset. (Above) Score distribution and survival plot from our implementation. (Below) Score distribution fitted to a normal distribution and survival plot from the Bentink et al. supplementary.}
\end{figure}

\pagebreak
\subsection*{Validation: Crijns dataset}
Our implementation of the Bentink et al. subtype classifier on the Crijns et al. dataset classified \Sexpr{sum(bentink.plots[["crijns"]][[3]]$Bentink.subtypes=="Angiogenic")} patients as `angiogenic' and \Sexpr{sum(bentink.plots[["crijns"]][[3]]$Bentink.subtypes=="nonAngiogenic")} as `non-angiogenic'.\footnote{In this case, the survival curves appear to differ from the curves provided in the supplementary text.}
\begin{figure}[H]
{\centering
<<bentink_crijns_survival, fig.width=9, fig.height=5, out.width="0.75\\textwidth", cache=FALSE>>=
grid.arrange(bentink.plots[["crijns"]][[1]], bentink.plots[["crijns"]][[2]], ncol=2)
@
}
\includegraphics[width=\textwidth]{bentink_supp2_crijns.png}
\caption{Crijns dataset. (Above) Score distribution and survival plot from our implementation. (Below) Score distribution fitted to a normal distribution and survival plot from the Bentink et al. supplementary.}
\end{figure}

\pagebreak
\subsection*{Validation: Denkert dataset}
Our implementation of the Bentink et al. subtype classifier on the Denkert et al. dataset classified \Sexpr{sum(bentink.plots[["denkert"]][[3]]$Bentink.subtypes=="Angiogenic")} patients as `angiogenic' and \Sexpr{sum(bentink.plots[["denkert"]][[3]]$Bentink.subtypes=="nonAngiogenic")} as `non-angiogenic'.\footnote{In this case, the survival curves appear to differ from the curves provided in the supplementary text.}
\begin{figure}[H]
{\centering
<<bentink_denkert_survival, fig.width=9, fig.height=5, out.width="0.75\\textwidth", cache=FALSE>>=
grid.arrange(bentink.plots[["denkert"]][[1]], bentink.plots[["denkert"]][[2]], ncol=2)
@
}
\includegraphics[width=\textwidth]{bentink_supp2_denkert.png}
\caption{Denkert dataset. (Above) Score distribution and survival plot from our implementation. (Below) Score distribution fitted to a normal distribution and survival plot from the Bentink et al. supplementary.}
\end{figure}

\pagebreak
\subsection*{Validation: Dressman dataset}
Our implementation of the Bentink et al. subtype classifier on the Dressman et al. dataset classified \Sexpr{sum(bentink.plots[["dressman"]][[3]]$Bentink.subtypes=="Angiogenic")} patients as `angiogenic' and \Sexpr{sum(bentink.plots[["dressman"]][[3]]$Bentink.subtypes=="nonAngiogenic")} as `non-angiogenic'.\footnote{Note the different x-axis range for the survival curves, as MetaGxOvarian has access to extended survival information. Other than this, the survival plots look very similar.}

\begin{figure}[H]
{\centering
<<bentink_dressman_survival, fig.width=9, fig.height=5, out.width="0.75\\textwidth", cache=FALSE>>=
grid.arrange(bentink.plots[["dressman"]][[1]], bentink.plots[["dressman"]][[2]], ncol=2)
@
}
\includegraphics[width=\textwidth]{bentink_supp2_dressman.png}
\caption{Dressman dataset. (Above) Score distribution and survival plot from our implementation. (Below) Score distribution fitted to a normal distribution and survival plot from the Bentink et al. supplementary.}
\end{figure}

\pagebreak
\subsection*{Validation: Mok dataset}
Our implementation of the Bentink et al. subtype classifier on the Mok et al. dataset classified \Sexpr{sum(bentink.plots[["mok"]][[3]]$Bentink.subtypes=="Angiogenic")} patients as `angiogenic' and \Sexpr{sum(bentink.plots[["mok"]][[3]]$Bentink.subtypes=="nonAngiogenic")} as `non-angiogenic'.\footnote{In this case, the survival curves appear to differ from the curves provided in the supplementary text.}
\begin{figure}[H]
{\centering
<<bentink_mok_survival, fig.width=9, fig.height=5, out.width="0.75\\textwidth", cache=FALSE>>=
grid.arrange(bentink.plots[["mok"]][[1]], bentink.plots[["mok"]][[2]], ncol=2)
@
}
\includegraphics[width=\textwidth]{bentink_supp2_mok.png}
\caption{Mok dataset. (Above) Score distribution and survival plot from our implementation. (Below) Score distribution fitted to a normal distribution and survival plot from the Bentink et al. supplementary.}
\end{figure}

\end{document}
