%\VignetteEngine{knitr::knitr}
\documentclass{article}

\usepackage{graphicx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage[table]{xcolor}
\usepackage{amsmath}
\setlength{\textfloatsep}{10pt plus 1.0pt minus 2.0pt}

\graphicspath{images}
%\newcommand{\sectionbreak}{\clearpage}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# Set options
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, error=FALSE, cache=FALSE)
options(replace.assign=TRUE,width=90)
par.original <- par()
days.per.month <- 30.4368
days.per.year <- 365.242
@

\title{Robustness of Ovarian Subtyping Schemes}

\author{Gregory M. Chen}
\date{\today}
\maketitle

<<load, cache=FALSE>>=
library(MetaGx)
library(gdata)
library(knitr)
library(HiDimDA)
library(survival)
library(reshape2)
library(genefu)
library(annotate)
library(hgu133plus2.db)
library(stringr)
# library(survMisc) 
library(xtable)
library(gridExtra)
library(Biobase)
library(GSVA)
library(sparsediscrim)
library(MetaGxOvarian)
library(survcomp)
library(NMF)
library(ggplot2)
library(e1071)
library(randomForest)
library(clue)
library(GEOquery)
@

<<load_data>>=
#source(system.file("extdata", "reproduce.results.patientselection.config", package="MetaGx2"))
#source(system.file("extdata", "patientselection.config", package="MetaGxOvarian"))
source("docs/reproduce.results.patientselection.config")
#rule.2 <- c("histological_type","^ser$")
#rule.3 <- c("summarystage","^late$")
#rule.4 <- c("summarygrade","^high$")
### use this line if you do not want to get rid of duplicates
rm(remove.duplicates)
rescale <- FALSE
rm(probe.gene.mapping)
source("docs/reproduce.results.patientselection.config")
source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
esets.not.rescaled.probes <- esets
rm(esets)

# This file was produced by classificationAcrossDatasets.Rnw
if(!file.exists("esets.not.rescaled.RData")) {
	stop("Run classificationAcrossDatasets.Rnw to generate file esets.not.rescaled.RData")
}
load("esets.not.rescaled.RData")

@
\tableofcontents 

\section{Introduction}

The discovery of molecular subtypes of ovarian cancer requires two steps: a clustering step, and a classification step. We sought to address the question of whether the methods used to define molecular subtypes are robust. In cluster analysis, robustness is a measure of how Tibshirani and Walther (2005) suggest Prediction Strength as a statistic for cluster validation. Prediction Strength is a measure of the similarity between pairwise co-memberships of a validation dataset from class labels assigned by (1) a clustering algorithm and (2) a classification algorithm trained on another dataset.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{images/prediction_strength_flowchart.png}
\end{figure}
\pagebreak

<<cluster_functions>>=
.getFilteredEsetByMAD <- function(eset, num.genes) {
  expression.matrix <- exprs(eset)
  mad.vals <- apply(expression.matrix, 1, mad)
  # expression.matrix has genes as rows, patients as columns
  eset <- eset[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  return(eset)
}

.getFilteredEsetByGeneList <- function(eset, gene.list, list.type=c("gene.symbol", "entrez.id")) {
  list.type <- match.arg(list.type)
  if(list.type == "gene.symbol") {
    eset <- eset[fData(eset)$gene %in% gene.list,]
  } else if(list.type == "entrez.id") {
    eset <- eset[fData(eset)$EntrezGene.ID %in% gene.list,]
  }
}

.getNMFClasses <- function(eset, filter.genes=TRUE, num.genes=2000, rank=4, nrun=100) {
  # rescale eset by z-score per gene
  expression.matrix <- exprs(eset)
  if(filter.genes) {
    mad.vals <- apply(exprs(eset), 1, mad)
    expression.matrix <- exprs(eset)[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  }
  if(any(expression.matrix < 0)) {
    expression.matrix <- expression.matrix + abs(min(expression.matrix))
  }
  
  nmf.out <- NMF::nmf(expression.matrix, rank=rank, nrun=nrun)
  # Clustering using consensus
  classes <- cutree(consensushc(nmf.out, dendrogram=FALSE), k=rank)
  
  classes <- as.factor(paste0("ConsensusNMF_", classes))
  # Clustering using matrix factorization
  #h.mat <- coef(nmf.out)
  #classes <- apply(h.mat, 2, which.max)
  #classes <- as.factor(paste0("NMF_", classes))
  return(classes)
}

.getConsensusKMeansClasses <- function(eset, filter.genes=TRUE, num.genes=2000, k=4, num.iterations=100) {
  expression.matrix <- exprs(eset)
  if(filter.genes) {
    mad.vals <- apply(exprs(eset), 1, mad)
    expression.matrix <- exprs(eset)[mad.vals >= tail(sort(mad.vals),num.genes)[1],]
  }
  expression.matrix <- t(expression.matrix)
  kmeans.out <- lapply(1:100, function(x) kmeans(expression.matrix, centers = k))
  cl.ensemble <- cl_ensemble(list=kmeans.out)
  consensus.out <- cl_consensus(cl.ensemble)
  membership.matrix <- matrix(as.vector(consensus.out$.Data), nrow=ncol(eset))
  
  classes <- apply(membership.matrix, 1, which.max)
  classes <- as.factor(paste0("kmeans_", classes))
  return(classes)
}
@

%TCGA

\section{TCGA}
<<TCGA_clustering_authorlist, cache=TRUE>>=
set.seed(120)
tcga.clustering.authordata <- read.delim("docs/TCGA_489_UE.top1500.txt", sep="\t")

tcga.gene.indices <- match(rownames(tcga.clustering.authordata), fData(esets.not.rescaled$TCGA)$gene)
tcga.gene.indices <- tcga.gene.indices[!is.na(tcga.gene.indices)]

verhaak.spreadsheet.data <- read.xls("docs/JCI65833sd1.xls", skip=1)
verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE")]

tcga.eset <- esets.not.rescaled$TCGA
tcga.eset <- tcga.eset[,tcga.eset$unique_patient_ID %in% verhaak.labels.table$ID]

tcga.implemented.clustering.authorlist <- data.frame(ID=tcga.eset$unique_patient_ID, nmf.classes=.getNMFClasses(tcga.eset[tcga.gene.indices,], filter.genes = FALSE, nrun=100))

tcga.merged.authorlist <- merge(tcga.implemented.clustering.authorlist, verhaak.labels.table)
@


We contacted the authors to acquire the original gene list used for clustering. Using \texttt{R} package \texttt{NMF}, we ran NMF with 100 iterations, and used hierarchical clustering on the co-membership matrix to define consensus cluster groupings.

\vspace*{10pt}
<<TCGA_contingency_authorlist, results="asis">>=
kable(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),c(3,4,2,1)], format="latex")
@

<<tcga_authorlist_contingency_heatmap, fig.width=7, fig.height=6, out.width="0.5\\textwidth">>=
.getContingencyHeatmap <- function(contingency.table) {
    contingency.table <- contingency.table[nrow(contingency.table):1,]
    contingency.matrix <- as.matrix(contingency.table)
    contingency.m <- melt(contingency.matrix)
    colnames(contingency.m) <- c("Published.classes", "New.cluster.classes", "value")
    
   # contingency.m$Published.classes <- factor(contingency.m$Published.classes, levels=rev(levels(contingency.m$Published.classes)))
    
    p <- ggplot(contingency.m, aes_string("New.cluster.classes", "Published.classes")) + 
      geom_tile(aes(fill = value), colour = "white") + 
      #scale_fill_gradient(name="Frequency", low="white", high="#CC0000", limits=c(0,800)) + 
      #ggtitle(paste0("Contingency table: ", subtype.name.pair[1], " vs ", subtype.name.pair[2])) +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(),legend.position = "none") +
    
      geom_text(label=as.character(contingency.matrix), colour="white")
    return(p)
}

.getContingencyHeatmap(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),c(3,4,2,1)])
@

%Repeating this process 16 times:
%<<tcga_authorlist_repeated, fig.width=24, fig.height=16, out.width="1\\textwidth">>=
%my.plots <- lapply(1:16, function(i) {
%  load(paste0("tcga.merged.authorlist.", i, ".RData"))
%  .getContingencyHeatmap(table(tcga.merged.authorlist$SUBTYPE, tcga.merged.authorlist$nmf.classes)[c(3,4,1,2),])
%})
%do.call(gridExtra::grid.arrange, my.plots)
%@

%Considering only the samples after removing the bottom 10\% by silhouette width:
%<<TCGA_contingency_authorlist_silhouette, results="asis">>=
%verhaak.spreadsheet.data <- read.xls("docs/JCI65833sd1.xls", skip=1)
%verhaak.labels.table <- verhaak.spreadsheet.data[verhaak.spreadsheet.data$DATASET == "TCGA-discovery", c("ID", "SUBTYPE", %"SILHOUETTE.WIDTH")]
%tcga.merged.authorlist <- merge(tcga.implemented.clustering.authorlist, verhaak.labels.table)
%tcga.merged.authorlist.silhouette <- tcga.merged.authorlist[tcga.merged.authorlist$SILHOUETTE.WIDTH > quantile(tcga%.merged.authorlist$SILHOUETTE.WIDTH, 0.1)]
%kable(table(tcga.merged.authorlist.silhouette$SUBTYPE, tcga.merged.authorlist.silhouette$nmf.classes)[,], format="latex")
%@


%Konecny
\pagebreak
\section{Konecny}

<<Konecny_clustering, cache=TRUE>>=
set.seed(840)

if(file.exists("konecny.eset.RData")) {
	load("konecny.eset.RData")
} else {
	konecny.unique.entrez.ids <- scan("docs/konecny.unique.entrez.ids.txt", what=character(0))
	konecny.original.eset <- getGEO("GSE53963", GSEMatrix=TRUE)[[1]]
	konecny.mad.vals <- apply(exprs(konecny.original.eset), 1, function(x) mad(x, na.rm=TRUE))
	konecny.eset <- konecny.original.eset
	fData(konecny.eset) <- fData(konecny.eset)[,c("ID", "GENE_SYMBOL", "GENE")]
	colnames(fData(konecny.eset)) <- c("probeset", "gene", "EntrezGene.ID")
	fData(konecny.eset)$best_probe <- FALSE
	 #remove NA probes
	konecny.eset <- konecny.eset[apply(exprs(konecny.eset), 1, function(x) all(!is.na(x))),]
	konecny.eset <- konecny.eset[!is.na(fData(konecny.eset)$EntrezGene.ID) & fData(konecny.eset)$EntrezGene.ID != "",]
	for(konecny.entrez.id in unique(fData(konecny.eset)$EntrezGene.ID)) {
	  probe.indices <- which(fData(konecny.eset)$EntrezGene.ID == konecny.entrez.id)
	  probe.index.to.keep <- probe.indices[which.max(apply(exprs(konecny.eset)[probe.indices,,drop=FALSE], 1, var))]
	  fData(konecny.eset)$best_probe[probe.index.to.keep] <- TRUE
	}
	konecny.eset <- konecny.eset[fData(konecny.eset)$best_probe,]
	rownames(konecny.eset) <- paste0("geneid.", fData(konecny.eset)$EntrezGene.ID)
	save(konecny.original.eset, file="konecny.original.eset.RData")
	save(konecny.eset, file="konecny.eset.RData")
}
konecny.supp5 <- read.xls("docs/jnci_JNCI_14_0249_s05.xls", header=FALSE)
#konecny.unique.entrez.ids <- fData(konecny.original.eset)$GENE[ fData(konecny.original.eset)$ID %in% konecny.supp5$V2 ]
#konecny.unique.entrez.ids <- konecny.unique.entrez.ids[!is.na(konecny.unique.entrez.ids) & konecny.unique.entrez.ids != ""]
#konecny.unique.entrez.ids <- unique(konecny.unique.entrez.ids)
#save(konecny.unique.entrez.ids, file="konecny.unique.entrez.ids.RData")
#write(konecny.unique.entrez.ids, file="docs/konecny.unique.entrez.ids.txt", ncolumns = 1)

konecny.original.eset.tocluster <- konecny.original.eset
fData(konecny.original.eset.tocluster) <- fData(konecny.original.eset.tocluster)[,c("ID", "GENE_SYMBOL", "GENE")]
colnames(fData(konecny.original.eset.tocluster)) <- c("probeset", "gene", "EntrezGene.ID")
konecny.mad.vals <- apply(exprs(konecny.original.eset.tocluster), 1, function(x) mad(x, na.rm=TRUE))
konecny.original.eset.tocluster <- konecny.original.eset.tocluster[konecny.mad.vals >= tail(sort(konecny.mad.vals), 2500)[1],]

# only keep non-NA probes
konecny.original.eset.tocluster <- konecny.original.eset.tocluster[apply(exprs(konecny.original.eset.tocluster), 1, function(x) all(!is.na(x))),]

konecny.eset.original.genes <- .getFilteredEsetByGeneList(eset = konecny.eset, gene.list = konecny.unique.entrez.ids, list.type = "entrez.id")
konecny.implemented.clustering.authorlist <- data.frame(OV=sub("[A-Za-z ]*", "", konecny.eset$source_name_ch2), nmf.classes=.getNMFClasses(konecny.eset.original.genes, filter.genes = FALSE, nrun=100))

konecny.supp3 <- read.xls("docs/jnci_JNCI_14_0249_s03.xls")
konecny.labels.table <- konecny.supp3[,c("OV", "MAYO.C4")]

konecny.merged.authorlist <- merge(konecny.implemented.clustering.authorlist, konecny.labels.table)

@

Konecny et al. performed clustering by first taking a subset of the top 2500 probesets by median absolute deviation (MAD), then used non-negative matrix factorization. We matched these probeset names to Entrez IDs from data from GEO, and performed clustering on the series matrix from GEO. In order to ensure all expression values were positive, all expression quantities were increased by the absolute value of the smallest (most negative) value. We ran NMF with 100 iterations, and used hierarchical clustering on the co-membership matrix to define consensus cluster groupings.


\vspace*{10pt}
<<konecny_contingency_authorlist, results="asis">>=
kable(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),c(3,2,4,1)], format="latex")
@

<<konecny_contingency_heatmap, fig.width=6, fig.height=5.5, out.width="0.45\\textwidth">>=
# table with rows published labels, columns de novo labels
.getContingencyHeatmap(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),c(3,2,4,1)])
@

%To get a feel for the consistency of the clustering procedure to random seeds, I performed the same clustering procedure (consensus NMF clustering with 100 iterations each) sixteen times. While the clusters were fairly consistent, in some cases (e.g. top-left) the consensus NMF clustering appeared to return only three clusters.\footnote{This could be due to the last step of the consensus NMF clustering that I used, which uses hierarchical clustering. It is unclear from the authors' description what method they used to generate the consensus classes.}
%
%<<konecny_16_plots, fig.width=24, fig.height=16, out.width="1\\textwidth">>=
%my.plots <- lapply(1:16, function(i) {
%  load(paste0("konecny.merged.authorlist.", i, ".RData"))
%  .getContingencyHeatmap(table(konecny.merged.authorlist$MAYO.C4, konecny.merged.authorlist$nmf.classes)[c(4,3,2,1),])
%})
%do.call(gridExtra::grid.arrange, my.plots)
%@

\pagebreak
%Tothill
\section{Tothill}

<<Tothill_clustering, cache=FALSE>>=
set.seed(132)
tothill.original.labels <- read.table("docs/tothill.supptable.1.classes.txt", header=TRUE, stringsAsFactors = FALSE)
tothill.original.labels <- tothill.original.labels[tothill.original.labels$group %in% c(1, 2, 3, 4, 5, 6),]
tothill.original.labels$group <- sub("^", "C", tothill.original.labels$group)

tothill.clustering.genes <- read.table("docs/tothill.clustering.genes.txt")
## This file was generated on July 31, 2015 with the following code:
#original.tothill.eset <- getGEO("GSE9891", GSEMatrix=TRUE)[[1]]
#original.tothill.eset <- original.tothill.eset[apply(exprs(original.tothill.eset), 1, function(x) any(x > 7) & var(x) >= 0.5),]
#tothill.clustering.genes <- data.frame(probe=fData(original.tothill.eset)$ID, entrez.id=fData(original.tothill.eset)$ENTREZ_GENE_ID)
#write.table(tothill.clustering.genes, file="docs/tothill.clustering.genes.txt")

tothill.implemented.clustering.kmeans <- data.frame(ID=esets.not.rescaled.probes$GSE9891$alt_sample_name, consensus.kmeans.classes=.getConsensusKMeansClasses(esets.not.rescaled.probes$GSE9891, k=6, num.iterations=1000))

tothill.implemented.clustering.kmeans$ID <- sub("X", "", tothill.implemented.clustering.kmeans$ID)

tothill.merged.kmeans <- merge(tothill.implemented.clustering.kmeans, tothill.original.labels)

@

The dataset of Tothill et al. (2008) consisted of \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)} patients, of which \Sexpr{ncol(esets.not.rescaled$GSE9891)} had late-stage, high-grade serious ovarian cancer. On their full dataset (n = \Sexpr{ncol(esets.not.rescaled.probes$GSE9891)}), they performed the following clustering procedure: probes were selected if at least one sample had an expression above 7.0, and global variance was above 0.5. They performed a form of consensus k-means clustering by performing k-means clustering 1000 times, identifyied a ``robust'' set of samples that co-clustered consistently, then used diagonal LDA and k-nearest neighbours to classify remaining samples. 

Using their full dataset, we filtered to probes with at least one sample with expression above 7.0, and variance above 0.5. We performed k-means clustering $B = 1000$ times, and used \texttt{R} package \texttt{clue} to perform consensus clustering using the criterion of Dimitriadou et al. (2002):
\begin{align*}
C_{\textnormal{consensus}} = \min_{C\in\mathcal{C}} \left\{ \sum_{b=1}^B d(C,C_b)^2 \right\}
\end{align*}
where $\mathcal{C}$ is the set of all possible clusterings, $d$ is the Euclidean distance, and $\{C_1, C_2, \ldots, C_B\}$ are the k-means clusterings.

Despite the difference between the consensus strategies, the cluster results appear to be similar:

\vspace*{10pt}
<<tothill_kmeans_contingency, results="asis", cache=FALSE>>=
kable(table(tothill.merged.kmeans$group, tothill.merged.kmeans$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(5,6,4,3,2,1)], format="latex")
#table(tothill.merged$nmf.classes, tothill.merged$group)
@
\vspace*{10pt}

<<tothill_6_contingency_heatmap, fig.width=6, fig.height=5.5, out.width="0.6\\textwidth", cache=FALSE>>=
.getContingencyHeatmap(table(tothill.merged.kmeans$group, tothill.merged.kmeans$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(5,6,4,3,2,1)])
@

<<tothill_kmeans_5_clustering, cache=FALSE>>=
tothill.implemented.clustering.kmeans.5 <- data.frame(ID=esets.not.rescaled.probes$GSE9891$alt_sample_name, consensus.kmeans.classes=.getConsensusKMeansClasses(esets.not.rescaled.probes$GSE9891, k=5, num.iterations=1000))
tothill.implemented.clustering.kmeans.5$ID <- sub("X", "", tothill.implemented.clustering.kmeans.5$ID)
tothill.merged.kmeans.5 <- merge(tothill.implemented.clustering.kmeans.5, tothill.original.labels)

@
\pagebreak
Since it appears that this implementation of k-means clustering is not capturing C6, we performed consensus k-means clustering with k = 5:
\vspace*{10pt}
<<tothill_kmeans_5_contingency, results="asis", cache=FALSE>>=
kable(table(tothill.merged.kmeans.5$group, tothill.merged.kmeans.5$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(4,5,2,1,3)], format="latex")
@
\vspace*{10pt}
<<tothill_5_contingency_heatmap, fig.width=5.5, fig.height=5.5, out.width="0.5\\textwidth", cache=FALSE>>=
.getContingencyHeatmap(table(tothill.merged.kmeans.5$group, tothill.merged.kmeans.5$consensus.kmeans.classes)[c(1,5,4,2,3,6),c(4,5,2,1,3)])
@

%Since both Konecny / TCGA used NMF of rank 4, it seemed interesting to investigate how this algorithm would perform on the Tothill dataset. The top 3000 genes were selected by top MAD, and NMF was performed. 
%
%NMF with rank = 4:

%<<tothill_nmf_clustering, eval=FALSE>>=
%
%tothill.implemented.clustering.nmf <- data.frame(ID=esets.not.rescaled$GSE9891$alt_sample_name, nmf.classes=.getNMFClasses(esets%.not.rescaled$GSE9891, num.genes = 3000, nrun=100))
%tothill.implemented.clustering.nmf$ID <- sub("X", "", tothill.implemented.clustering.nmf$ID)
%tothill.merged.nmf <- merge(tothill.implemented.clustering.nmf, tothill.original.labels.hgs)
%@
%\vspace*{10pt}
%<<tothill_nmf_contingency, results="asis", eval=FALSE>>=
%kable(table(tothill.merged.nmf$group, tothill.merged.nmf$nmf.classes)[c(1,4,3,2),c(2,3,4,1)], format="latex")
%#table(tothill.merged$nmf.classes, tothill.merged$group)
%@
%
%<<tothill_4_contingency_heatmap, fig.width=5, fig.height=4, out.width="0.4\\textwidth", eval=FALSE>>=
%.getContingencyHeatmap(table(tothill.merged.nmf$group, tothill.merged.nmf$nmf.classes)[c(1,4,3,2),c(2,3,4,1)])
%@

\pagebreak
\section{Prediction Strength}

\Sexpr{knit_child('robustness_validation.Rnw')}

\end{document}
