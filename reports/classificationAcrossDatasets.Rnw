
\pagebreak
\chapter[Classification Across Datasets]{Classification of a Compendium of Ovarian Datasets Ovarian under Published Subtyping Schemes}

<<setup2, include=FALSE, cache=FALSE>>=
# Set options
rm(list=ls())
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, error=FALSE, cache=TRUE)
options(replace.assign=TRUE,width=90)
par.original <- par()
days.per.month <- 30.4368
days.per.year <- 365.242
@


%\tableofcontents 

<<load2, cache=FALSE>>=
library(MetaGx)
library(gdata)
library(HiDimDA)
library(survival)
library(reshape2)
library(genefu)
library(annotate)
library(hgu133plus2.db)
# library(survMisc)
#  library(vcd)
library(xtable)
library(Biobase)
library(GSVA)
library(sparsediscrim)
library(MetaGxOvarian)
library(survcomp)
library(ggplot2)
library(e1071)
library(randomForest)
library(grid)
library(gridExtra)
library(survcomp)
library(metafor)
library(genefu)
library(Biobase)
library(dplyr)
library(VennDiagram)
library(GGally)
@

<<load_data2>>=
source("docs/reproduce.results.patientselection.config")

rule.1 <- c("sample_type","^tumor$")
rule.2 <- c("histological_type","^ser$")
rule.3 <- c("summarystage","^late$")
rule.4 <- c("summarygrade","^high$")
  
  
### use this line if you do not want to get rid of duplicates
rm(remove.duplicates)
rescale <- FALSE

## print out the rules ; print out the summaries 
# cat("The following rules were applied while filtering the datasets: \n")
# if (exists(rule.1)){
#   cat(rule.1)
# }

source(system.file("extdata", "createEsetList.R", package="MetaGxOvarian"))
  
esets.not.rescaled <- esets
# remove any genes with NA values
esets.not.rescaled <- lapply(esets.not.rescaled, function(eset) eset[apply(exprs(eset), 1, function(x) all(!is.na(x))),])
# only keep esets with at least 10000 genes
esets.not.rescaled <- esets.not.rescaled[sapply(esets.not.rescaled, function(x) nrow(x) > 10000)]

save(esets.not.rescaled, file="esets.not.rescaled.RData")
@

<<classify_data>>=
set.seed(450)
# Subtype classification
esets.not.rescaled.classified <- esets.not.rescaled
# Remove TCGA.RNASeqV2
esets.not.rescaled.classified <- esets.not.rescaled.classified[names(esets.not.rescaled.classified) != "TCGA.RNASeqV2"]

esets.not.rescaled.classified <- lapply(esets.not.rescaled.classified, function(eset) {
  konecny.out <- getKonecnySubtypes(eset)
  annotated.eset <- konecny.out[[1]]
  annotated.eset$Konecny.margins <- apply(konecny.out$spearman.cc.vals, 1, function(x) max(x) - sort(x)[3])
  return(annotated.eset)
  })
esets.not.rescaled.classified <- lapply(esets.not.rescaled.classified, function(eset) {
  verhaak.out <- getVerhaakSubtypes(eset)
  annotated.eset <- verhaak.out[[1]]
  annotated.eset$Verhaak.margins <- apply(verhaak.out$gsva.out, 1, function(x) max(x) - sort(x)[3])
  return(annotated.eset)
  })
esets.not.rescaled.classified <- lapply(esets.not.rescaled.classified, function(eset) {
  helland.out <- getHellandSubtypes(eset)
  annotated.eset <- helland.out[[1]]
  annotated.eset$Helland.margins <- apply(helland.out$subtype.scores, 1, function(x) max(x) - sort(x)[3])
  return(annotated.eset)
  })
esets.not.rescaled.classified <- lapply(esets.not.rescaled.classified, function(eset) getBentinkSubtypes(eset)[[1]])
save(esets.not.rescaled.classified, file = "esets.not.rescaled.classified.RData")
@

<<Concordantly classified patients>>=
subtype.correspondances <- data.frame(Konecny=c("C1_immL", "C2_diffL", "C3_profL", "C4_mescL"),
                                      Verhaak=c("IMR", "DIF", "PRO", "MES"),
                                      Helland=c("C2", "C4", "C5", "C1"))


esets.not.rescaled.classified.concordant <- lapply(esets.not.rescaled.classified, function(eset) {
concordant <- match(eset$Konecny.subtypes, subtype.correspondances$Konecny) ==
  match(eset$Verhaak.subtypes, subtype.correspondances$Verhaak) &
  match(eset$Verhaak.subtypes, subtype.correspondances$Verhaak) ==
  match(eset$Helland.subtypes, subtype.correspondances$Helland)
  return(eset[,concordant])
})

save(esets.not.rescaled.classified.concordant, file="esets.not.rescaled.classified.concordant.RData")
@

%\tableofcontents
<<Pooled_survival_prepare_data>>=
subtype.names <- c("Konecny", "Verhaak", "Helland", "Bentink")


esets.all.data <- esets.not.rescaled.classified[sapply(esets.not.rescaled.classified, ncol) > 0]
eset.all.data.names <- names(esets.not.rescaled.classified)
esets.all <-lapply(eset.all.data.names, function(eset.name) {
  esets.all.data[[eset.name]]$data.source <- eset.name
  return(esets.all.data[[eset.name]])
  })
names(esets.all) <- eset.all.data.names


pooled.subtypes <- do.call(rbind, 
    lapply(esets.all, function(eset) pData(eset)[,c("days_to_death", "vital_status", "data.source", paste0(subtype.names, ".subtypes"), paste0(c("Konecny", "Verhaak", "Helland"), ".margins"))]        
           ))

colnames(pooled.subtypes)[4:7] <- sub(".subtypes", "", colnames(pooled.subtypes)[4:7])

pooled.subtypes$Konecny <- factor(pooled.subtypes$Konecny, levels(pooled.subtypes$Konecny)[c(1,2,3,4)])
pooled.subtypes$Verhaak <- factor(pooled.subtypes$Verhaak, levels(pooled.subtypes$Verhaak)[c(2,1,4,3)])
pooled.subtypes$Helland <- factor(pooled.subtypes$Helland, levels(pooled.subtypes$Helland)[c(2,3,4,1)])
pooled.subtypes$Bentink <- factor(pooled.subtypes$Bentink, levels(pooled.subtypes$Bentink)[c(2,1)])

pooled.subtypes$years_to_death = pooled.subtypes$days_to_death / days.per.year
pooled.subtypes$days_to_death <- NULL
pooled.subtypes$vital_status <- pooled.subtypes$vital_status == "deceased"

pooled.subtypes$data.source <- factor(pooled.subtypes$data.source, levels=eset.all.data.names)

# Censor to ten years
censor.time.out <- survcomp::censor.time(surv.time = pooled.subtypes$years_to_death, surv.event = pooled.subtypes$vital_status, time.cens = 10)
pooled.subtypes$years_to_death <- censor.time.out$surv.time.cens
pooled.subtypes$vital_status <- censor.time.out$surv.event.cens

pooled.subtypes$surv.obj <- Surv(time = pooled.subtypes$years_to_death, event = pooled.subtypes$vital_status)

# patients with survival data
pooled.subtypes.survival = na.omit(pooled.subtypes)
@

%\pagebreak

\section{Data Description}

From MetaGxOvarian, we identified \Sexpr{nrow(pooled.subtypes)}  (\Sexpr{nrow(pooled.subtypes.survival)} with survival data) patients from diagnosed with high-grade serous ovarian carcinoma.

<<Dataset_table, results='asis'>>=
data.counts <- as.data.frame(table(pooled.subtypes$data.source))
colnames(data.counts) <- c("Data Source", "Number of Patients")
data.counts[,1] <- as.character(data.counts[,1])
data.counts <- rbind(data.counts, list("Total", sum(data.counts[,2])))
print(xtable(data.counts), include.rownames=FALSE)
@

%\pagebreak
\section{Pairwise subtype associations}
We applied our implementation of the subtype classifiers of Helland, Verhaak, Konecny, and Bentink to these datasets. 
% Survival analysis moved to end of document by Lavanya

\begin{figure}[H]
\centering
<<Contingency_tables, out.width="0.55\\textwidth", fig.width=8, fig.height=15>>=

pair.matrix <- combn(subtype.names,2)
# Modifications to order for aesthetic reasons
pair.matrix <- pair.matrix[,c(4,5,1,3,2,6)]
pair.matrix <- pair.matrix[2:1,]
pair.matrix[,5] <- pair.matrix[2:1,5]

contingency.plots <- apply(pair.matrix, 2, function(subtype.name.pair) {
  contingency.matrix <- as.matrix(table(pooled.subtypes[,subtype.name.pair[1]],pooled.subtypes[,subtype.name.pair[2]]))
  contingency.m <- melt(contingency.matrix)
  colnames(contingency.m) <- c(subtype.name.pair[1], subtype.name.pair[2], "value")
  contingency.m[,subtype.name.pair[1]] <- factor(contingency.m[,subtype.name.pair[1]], levels = levels(pooled.subtypes[,subtype.name.pair[1]]))
  contingency.m[,subtype.name.pair[2]] <- factor(contingency.m[,subtype.name.pair[2]], levels = levels(pooled.subtypes[,subtype.name.pair[2]]))
  
  
  
  pretty_p <- function (pvalue, max_precision = 5, p = "p-value") {
    required_precision <- ceiling(-log10(pvalue))

    if (required_precision > max_precision)
        paste0(p, "<", sprintf('%.*f', max_precision, 0.1 ** max_precision))
    else
        paste0(p, "~", sprintf('%.*f', required_precision + 1, pvalue))
}

p_value_text <- chisq.test(pooled.subtypes[,subtype.name.pair[1]],pooled.subtypes[,subtype.name.pair[2]])["p.value"]  %>% as.numeric %>% pretty_p
  
  cramers.v <- vcd::assocstats(table(pooled.subtypes[,subtype.name.pair[1]],pooled.subtypes[,subtype.name.pair[2]]))[["cramer"]]
 
cramers_v_text <- sprintf("Cramer's v = %.2f", cramers.v)

  stat.text1 <- sprintf("Percent Concordant = %.2f%%",100 * sum(diag(contingency.matrix)) / sum(contingency.matrix))
  
  stat.text2 <- paste(p_value_text, cramers_v_text, sep="; ")
  
 
  
  p <- ggplot(contingency.m, aes_string(subtype.name.pair[1], subtype.name.pair[2])) + 
    geom_tile(aes(fill = value), colour = "black") + 
    scale_fill_gradient(name="Frequency", low="white", high="#CC0000", limits=c(0,600)) + 
    #ggtitle(paste0("Contingency table: ", subtype.name.pair[1], " vs ", subtype.name.pair[2])) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), legend.position = "none", axis.text.y = element_text(angle = 90)) +
    geom_text(label=as.character(contingency.matrix), colour="black") + xlab(paste0(subtype.name.pair[1], "\n", stat.text1, "\n", stat.text2))
    
    
  return(p)
})

grid.arrange(contingency.plots[[1]], contingency.plots[[2]], contingency.plots[[3]], contingency.plots[[4]], contingency.plots[[5]], contingency.plots[[6]],ncol=2, widths=c(10,6))
#pdf("subtype_classifier_conting_fours.pdf", width=17.5, height=5)
#do.call(grid.arrange, c(contingency.plots[1:3], ncol = 3))
#dev.off()
#pdf("subtype_classifier_conting_bentink.pdf", width=17.5, height=2.75)
#do.call(grid.arrange, c(contingency.plots[4:6], ncol = 3))
#dev.off()
@
\caption{Pairwise contingency tables indicated associations between the four subtype classifiers. We restricted our attention to the \Sexpr{nrow(pooled.subtypes.survival)} patients for which survival information was available. The subtypes of Bentink et al. appears to most strongly resemble the Mesenchymal subtype of Verhaak, subtype C4 of Konecny, and subtype C1 of Helland.}
\end{figure}

<<generate_figs_for_marginal_analysis>>=
margin.contingency.plots <- apply(pair.matrix[,c(1,3,5)], 2, function(subtype.name.pair) {
    margins.1 <- pooled.subtypes[,paste0(subtype.name.pair[1], ".margins")]
    margins.2 <- pooled.subtypes[,paste0(subtype.name.pair[2], ".margins")]
    
    margins.1 <- ecdf(margins.1)(margins.1)
    margins.2 <- ecdf(margins.2)(margins.2)
    
    plots <- lapply(c(100, 75, 50, 25), function(x) {
      lower.bound <- 1 - x / 100
      margin.boolean <- margins.1 > lower.bound & margins.2 > lower.bound
      contingency.matrix <- as.matrix(table(pooled.subtypes[,subtype.name.pair[1]][margin.boolean],pooled.subtypes[,subtype.name.pair[2]][margin.boolean]))
      contingency.m <- melt(contingency.matrix)
      colnames(contingency.m) <- c(subtype.name.pair[1], subtype.name.pair[2], "value")
      contingency.m[,subtype.name.pair[1]] <- factor(contingency.m[,subtype.name.pair[1]], levels = levels(pooled.subtypes[,subtype.name.pair[1]]))
      contingency.m[,subtype.name.pair[2]] <- factor(contingency.m[,subtype.name.pair[2]], levels = levels(pooled.subtypes[,subtype.name.pair[2]]))
      title.text <- paste0("Top ", x, "%")
      if(x == 100) {
          title.text <- "All Data"
      }
      
       p <- ggplot(contingency.m, aes_string(subtype.name.pair[1], subtype.name.pair[2])) + 
      geom_tile(aes(fill = value), colour = "black") + 
      scale_fill_gradient(name="Frequency", low="white", high="#CC0000", limits=c(0,sum(contingency.matrix)/2)) + 
      ggtitle(title.text) +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), legend.position = "none", axis.text.y = element_text(angle = 90)) +
      geom_text(label=as.character(contingency.matrix), colour="black")
      return(p)
    })
  return(plots)
})
# Create the margin scatterplots

margin.scatterplots.data <- function(subtype.name.pair,get.percent_removed = FALSE) {
    margins.1 <- pooled.subtypes[,paste0(subtype.name.pair[1], ".margins")]
    margins.2 <- pooled.subtypes[,paste0(subtype.name.pair[2], ".margins")]  
    margins.1 <- ecdf(margins.1)(margins.1)
    margins.2 <- ecdf(margins.2)(margins.2) 
    xvals <- seq(0, 1, length.out = 3000)
    percent_removed_concordance <- sapply(xvals, function(x) {
      margin.boolean <- margins.1 > x & margins.2 > x
      contingency.matrix <- as.matrix(table(pooled.subtypes[,subtype.name.pair[1]][margin.boolean],pooled.subtypes[,subtype.name.pair[2]][margin.boolean]))
      total.patients <- pooled.subtypes %>% nrow
      percent_removed <- (total.patients - sum(contingency.matrix))/total.patients * 100
      c(percent_removed, sum(diag(contingency.matrix)) / sum(contingency.matrix))
    }) 
    m <- percent_removed_concordance %>% as.matrix
    rownames(m) <- c("percent.removed", "concordance")
    if (get.percent_removed) m["percent.removed",] else c(m["concordance",])
  }

xvals <- seq(0, 1, length.out = 3000)

margin.scatterplots <- apply(pair.matrix[,c(1,3,5)], 2, function(subtype.name.pair) {   
    concordance <- margin.scatterplots.data(subtype.name.pair)
    scatterplot.df <- data.frame(margin=xvals * 100, concordance=concordance)
    scatterplot.df <- scatterplot.df[!is.na(scatterplot.df$concordance),]
    scatterplot <- ggplot(scatterplot.df, aes(x=margin, y=concordance)) + geom_point(size=0) + geom_line(size=0) + theme_bw() + xlab("margin percentile") + ylab("Concordance") + ggtitle(paste0(subtype.name.pair[1], " vs ", subtype.name.pair[2])) + ylim(0, 1)
    return(scatterplot)
  })
@

<<margin_scatterplots_combined, fig.keep = 'last'>>=
pairwise_concordances<- apply(pair.matrix[,c(1,3,5)], 2, margin.scatterplots.data)
  percent_removed <- apply(pair.matrix[,c(1,3,5)], 2, function (p) margin.scatterplots.data(p,get.percent_removed = TRUE))
 scatterplot1.df <- data.frame( 
                               percent =percent_removed[,1], 
                               concordance =pairwise_concordances[,1]
                               ) 
scatterplot2.df <- data.frame( 
                               percent =percent_removed[,2], 
                               concordance =pairwise_concordances[,2]
                               )
scatterplot3.df <- data.frame( 
                               percent =percent_removed[,3],
                               concordance =pairwise_concordances[,3]
                               )

 

scatterplots.combined <- ggplot(scatterplot1.df,aes(x = percent,y = concordance))+geom_line(aes(color="Helland_vs_Verhaak")) + geom_line(data = scatterplot2.df,aes(color="Verhaak_vs_Konecny")) + geom_line(data = scatterplot3.df,aes(color="Konecny_vs_Helland")) + theme_bw() + xlab("% of dataset removed") + ylab("Concordance") + ggtitle("Two-way Concordances") + ylim(0, 1) + theme(legend.position = c(0.5, 0.5)) +  labs(color="") + scale_colour_manual("", values=c("gold", "orange", "orchid3")) 

@



%\pagebreak

\subsection{Helland vs Verhaak}
\begin{figure}[H]
<<Helland_vs_Verhaak_margin_contingency, out.width="0.75\\textwidth">>=
do.call(grid.arrange, margin.contingency.plots[[1]], c(ncol=2))
@

<<Helland_vs_Verhaak_margin_scatter, fig.width=5, fig.height=5, out.width="0.4\\textwidth">>=
margin.scatterplots[[1]]
@

\caption{Pairwise subtype association between the Helland and Verhaak classifiers. Each classifier produces a real-valued subtype score per patient; from this score, a margin value can be defined as the difference between the top two subtype scores. We assessed subtype association, considering only patients for whom the margin values are in the top 75\%, top 50\%, and top 25\% of both classifiers. Using these margin value cutoffs, we observed an increase in between-classifier concordance.}
\end{figure}

\subsection{Konecny vs Verhaak}

\begin{figure}[H]

<<Konecny_vs_Verhaak_margin_contingency, out.width="0.75\\textwidth">>=
do.call(grid.arrange, margin.contingency.plots[[2]], c(ncol=2))
@

<<Konecny_vs_Verhaak_margin_scatter, fig.width=5, fig.height=5, out.width="0.4\\textwidth">>=
margin.scatterplots[[2]]
@

\caption{Pairwise subtype association between the Konecny and Verhaak classifiers. Each classifier produces a real-valued subtype score per patient; from this score, a margin value can be defined as the difference between the top two subtype scores. We assessed subtype association, considering only patients for whom the margin values are in the top 75\%, top 50\%, and top 25\% of both classifiers. Using these margin value cutoffs, we observed an increase in between-classifier concordance.}
\end{figure}

\subsection{Helland vs Konecny}

\begin{figure}[H]

<<Helland_vs_Konecny_margin_contingency, out.width="0.75\\textwidth">>=
do.call(grid.arrange, margin.contingency.plots[[3]], c(ncol=2))
@

<<Helland_vs_Konecny_margin_scatter, fig.width=5, fig.height=5, out.width="0.4\\textwidth">>=
margin.scatterplots[[3]]
@

\caption{Pairwise subtype association between the Helland and Konecny classifiers. Each classifier produces a real-valued subtype score per patient; from this score, a margin value can be defined as the difference between the top two subtype scores. We assessed subtype association, considering only patients for whom the margin values are in the top 75\%, top 50\%, and top 25\% of both classifiers. Using these margin value cutoffs, we observed an increase in between-classifier concordance.}
\end{figure}

% The below code is not getting printed
% <<Forest_plots, eval=FALSE>>=
% out <- lapply(ovarian.publication.years$dataset, function(dataset.name) {
%   current.survival.df <- pooled.subtypes[pooled.subtypes$data.source == dataset.name,]
%   survcomp::hazard.ratio(x = current.survival.df$Konecny, surv.time = current.survival.df$years_to_death, surv.event = current.survival.df$vital_status)
%   })
% names(out) <- ovarian.publication.years$dataset
% 
% rma.out <- lapply(1:3, function(i) {
%   loghr.vals <- sapply(out, function(x) x$coef[i])
%   loghr.se <- sapply(out, function(x) diag(x$se)[i])
%   rma(loghr.vals, sei=loghr.se, method="REML", slab=names(out))
%   })
% 
% forest(rma.out[[3]], refline=0, annotate=FALSE, atransf=exp, xlim=c(-5, 4), addfit=FALSE, ylim=c(-1.5,length(out) + 3), at=log(c(0.125, 0.25, 0.5, 1, 2, 4, 8, 16, 32)))
% abline(h=0, lwd=1)
% addpoly(rma.out[[3]], mlab="Random Effects", row=-1, atransf=exp, annotate=TRUE)
% @

\section{Contingency of subtypes}

<<Subtype_mapping>>=
# map the subtypes across the different algorithms
subtypes = lapply(1:3,(function(i) {levels(pooled.subtypes[,subtype.names[[i]]])}))
@
 

Based on the pairwise concordance, we observe that the subtypes in the different schemes appear to follow a clear one-to-one mapping, except in the case of the Bentink, which maps the IMR, DIF, and PRO subtypes of Verhaak (and the corresponding subtypes in other schemes) to non-Angiogenic and the MES subtype to Angiogenic. The table below shows the mapping. 


<<Subtype_map_table, results='asis'>>=
subtype.map <- as.data.frame(subtypes)
subtype.map$"Bentink" <- c("nonAngiogenic", "nonAngiogenic", "nonAngiogenic", "Angiogenic")
colnames(subtype.map) <- subtype.names

print(xtable(subtype.map), include.rownames=FALSE)
@

<<Data_setup, cache = FALSE>>=
# Extract margins for each scheme
margins1 <- function (only.survival) { 
  p = (if (only.survival) pooled.subtypes.survival
  else pooled.subtypes)
  m = p[,paste0(subtype.names[[1]], ".margins")]    
  ecdf(m)(m) 
}

margins2 <- function (only.survival) { 
  p = (if (only.survival) pooled.subtypes.survival
  else pooled.subtypes)
  m = p[,paste0(subtype.names[[2]], ".margins")]    
  ecdf(m)(m) 
}  

margins3 <- function (only.survival) { 
  p = (if (only.survival) pooled.subtypes.survival
  else pooled.subtypes)
  m = p[,paste0(subtype.names[[3]], ".margins")]    
  ecdf(m)(m) 
}

# get marginal data 
get_margin <- function(lower.bound, only.survival = FALSE){  
    margins1(only.survival) > lower.bound & 
    margins2(only.survival) > lower.bound & 
    margins3(only.survival) > lower.bound
  }

# the code below fetches the marginal data (including the ones where 100% remain) for each subtype
get_marginal_data_top <- function(top_margin_percent,subtype.name, only.survival = FALSE) {
    lower.bound <- 1 - top_margin_percent / 100
    margin.boolean <- get_margin(lower.bound, only.survival)
    p = (if (only.survival) pooled.subtypes.survival
  else pooled.subtypes)
    tmp = p[,subtype.name][margin.boolean] %>% data.frame
    row.names(tmp) <- row.names(p)[margin.boolean]
    names(tmp) <- "tmp_subtype"
    tmp # tmp can be obtained in a more simpler way?
  }

# given a subtype.name (scheme) position and the subtype, find the list of patients in the subtype in the scheme 


filtered_dataset_all_subtypes <- 
              function(margin_percent, only.survival = FALSE) 
                lapply(subtype.names[1:3], function (sn) 
                  get_marginal_data_top(margin_percent,sn, only.survival))

get_patients <- function(pos_subtype.name,subtype_order, margin_percent, only.survival = FALSE){
  subtypes$subtype.name <- subtypes[[pos_subtype.name]]
  filtered_dataset = 
    filtered_dataset_all_subtypes(margin_percent, only.survival)[[pos_subtype.name]] 
  row.names(filtered_dataset)[which(filtered_dataset$"tmp_subtype" == subtypes$subtype.name[[subtype_order]])] 
}

# Given the mapped subtype number (called subtype_order), fetch the patients in each scheme in the subtype 
get_subtype_patients <- function(subtype_order,margin_percent, methods_considered = 1:3, only.survival = FALSE){  
 lapply(methods_considered, function(i) {get_patients(i,subtype_order,margin_percent, only.survival)}) 
}

# Get the subtype_patients for each subtype across schemes and find overlaps 

get_overlaps <- function(margin_percent, methods_considered = 1:3, only.survival = FALSE) {
  lapply(1:4, function(subtype_order) {
    output <- NULL
    output$parts <- calculate.overlap(x=get_subtype_patients(subtype_order,margin_percent, methods_considered, only.survival))
    output$lengths <- sapply(output$parts, length)
    output
  })
}

get_sum <- function (ov_m, only.survival = FALSE) {
  sapply(1:4, function(i) {ov_m[[i]]$lengths %>% sum}) %>% sum
}
total_patients <- get_sum(get_overlaps(100))

# Concordance plots
margin_vals <- seq(100, 0, length.out = 3000)
get_overlaps_margin <- 
  lapply(margin_vals, function(mval) {get_overlaps(mval)})
  


percent_removed <- lapply(1:3000, function(i) {
  total_remaining = 
    get_overlaps_margin[[i]] %>% get_sum
  100*(total_patients - total_remaining)/total_patients
})
percent = percent_removed %>% as.numeric

##set up for scatter plot
xvals <- seq(0, 1, length.out = 3000)
margin.concordance <- function (subtype_order = 1, all = FALSE) {   
  concordance <- 
    if (all) 
    {
      lapply(1:3000, function(i) {
    go_all = get_overlaps_margin[[i]]
    common = lapply(1:4,function (subtype_order) go_all[[subtype_order]]$lengths[[1]])%>% unlist %>% sum 
    npatients = lapply(1:4,function (subtype_order) go_all[[subtype_order]]$lengths %>% sum)%>% unlist %>% sum 
    common/npatients
      })
    } else
    lapply(1:3000, function(i) {
    go <- get_overlaps_margin[[i]][[subtype_order]]$lengths  
    go[[1]]/sum(go)
  })
}


  scatterplot.df <- data.frame(IMR = margin.concordance(1)%>%as.numeric, DIF = margin.concordance(2)%>%as.numeric, PRO = margin.concordance(3)%>%as.numeric, MES = margin.concordance(4)%>%as.numeric, overall = margin.concordance(1, all = TRUE)%>%as.numeric, percent = percent)
  scatterplot_melt.df <- melt(scatterplot.df, id = "percent") 
scatterplot_melt.df <- scatterplot_melt.df[order(scatterplot_melt.df$value, scatterplot_melt.df$variable, decreasing = TRUE),]
  legend_length <- length(unique(scatterplot_melt.df$variable))
legend_breaks <- scatterplot_melt.df$variable[1:legend_length]
  
    subtype_scatterplots <- ggplot(scatterplot_melt.df, aes(y=value, x = percent, colour=variable)) + scale_colour_manual("", values=c("red","green","blue","violet", "black")) + geom_line() + theme_bw() + xlab("% of dataset removed") + ylab("Concordance") + ylim(0, 1) + ggtitle("Three-way Concordance") + theme(legend.position = c(0.75, 0.25)) 
@

We sought to further investigate the association of margin values with subtype concordance, under the hypothesis that patients with had higher margin values were more `confidently' classified, and more concordantly classified between subtypes. We restricted our attention to the Helland, Konecny, and Verhaak classifiers, since they have the same number of subtypes.
In the following plot, we can see the relationship between the margin cutoffs and the percent of dataset removed.

\begin{figure}[H]
<<margin_cuttoffs_versus_percentage removed, fig.width=8, fig.height=7, out.width="0.6\\textwidth">>=
xvals <- seq(0, 1, length.out = 3000)
margin_scatterplot.df <- data.frame(margin = xvals, percent = percent)
margin_cutoff = margin_scatterplot.df$margin[1500]
points.df <- data.frame(cutoff=margin_cutoff, percent_removed=percent[margin_scatterplot.df$margin == margin_cutoff])
ggplot(margin_scatterplot.df, aes(y=margin, x = percent)) + 
    geom_point(size=3) + geom_line(size=3) + theme_bw() + 
    xlab("Percentage of dataset removed") + ylab("Margin cutoff") + ylim(0, 1) + geom_segment(aes(x=0,y=cutoff,xend=percent_removed,yend=cutoff, color="cutoff"),data=points.df) + geom_segment(aes(x=percent_removed,y=0,xend=percent_removed,yend=cutoff, color="cutoff"),data=points.df) + ggtitle("Margin Cutoffs versus Percentage of Dataset Removed")  + coord_flip()
@

\caption{The percentage of dataset removed for different margin cutoffs. The margin cutoff is used as a quantile, and patients above that margin quantile in all three classifiers are retained.}

\end{figure}

<<filtered.dataset>>=
## below is the code added by Lavanya for the filtered dataset

# the below dataset gives only those patients that have margins above margin_cutoff - each column consists of the individual schemes 
Filtered_pooled.subtypes=pooled.subtypes[get_margin(margin_cutoff),] 
## Filtered_pooled.subtypes.survival is the patients from Filtered_pooled.subtypes that has survival data 
Filtered_pooled.subtypes.survival=pooled.subtypes.survival[get_margin(margin_cutoff,TRUE),] 

# the below dataset gives the patients that have margins above margin_cutoff and also sharing the same subtype name across the scheme 
filtered_overlaps = lapply(1:4, function (i) {get_overlaps(100*(1 - margin_cutoff))[[i]]$parts[[1]]}) %>% unlist
Filtered_intersection_pooled.subtypes = pooled.subtypes[filtered_overlaps,] 
filtered_overlaps.survival = intersect(x = filtered_overlaps, y = rownames(pooled.subtypes.survival))
Filtered_intersection_pooled.subtypes.survival = pooled.subtypes.survival[filtered_overlaps.survival,] 

## Check if Filtered_intersection_pooled.subtypes is a subset of Filtered_pooled.subtypes
a = row.names(Filtered_intersection_pooled.subtypes)
b = row.names(Filtered_pooled.subtypes)
if (!all(a %in% b)) {
  print("Error in filtered datasets")
  rm(Filtered_intersection_pooled.subtypes)
}

# Another method to calculate Filtered_intersection_pooled.subtypes.survival from directly Filtered_pooled.subtypes.survival using Subtype_mapping object "subtype" defined above
 tmp_filtered <- Filtered_pooled.subtypes.survival
 levels(tmp_filtered$"Konecny") <- subtypes[[2]]
 levels(tmp_filtered$"Helland") <- subtypes[[2]]
 
 x <- tmp_filtered$"Konecny" == tmp_filtered$"Verhaak"
 y <- tmp_filtered$"Helland" == tmp_filtered$"Verhaak"
 # tmp_filtered[x&y,] must be same as Filtered_intersection_pooled.subtypes.survival
 c = row.names(tmp_filtered[x&y,])
 if (!all(c %in% b)) {
   print("Error in filtered datasets")
   rm(Filtered_intersection_pooled.subtypes.survival)
 }


#### intersection_pooled.subtypes and intersection_pooled.subtypes.survival are the patients which are unanimously classified under the same subtypes across the methods and those which have survival data, respectively; intersection_pooled.subtypes must contain Filtered_intersection_pooled.subtypes (and must be the same as the cases_to_keep in getConsensusovarianSubtypes.R)

# the below dataset gives the patients that have margins above margin_cutoff and also sharing the same subtype name across the scheme 
filtered_overlaps_all = lapply(1:4, function (i) {get_overlaps(100)[[i]]$parts[[1]]}) %>% unlist
intersection_pooled.subtypes = pooled.subtypes[filtered_overlaps_all,] 
filtered_overlaps.survival_all = intersect(x = filtered_overlaps_all, y = rownames(pooled.subtypes.survival))
intersection_pooled.subtypes.survival = pooled.subtypes.survival[filtered_overlaps.survival_all,] 

## Check if intersection_pooled.subtypes.survival is a subset of intersection_pooled.subtypes
q = row.names(intersection_pooled.subtypes)
p = row.names(intersection_pooled.subtypes.survival)
if (!all(p %in% q)) {
  print("Error in filtered datasets")
  rm(intersection_pooled.subtypes)
  rm(intersection_pooled.subtypes.survival)
}
 
save(Filtered_intersection_pooled.subtypes, file="Filtered_intersection_pooled.subtypes.RData")
save(intersection_pooled.subtypes, file="intersection_pooled.subtypes.RData")
@


<<margin_cutoff>>=
All=pooled.subtypes[,"data.source"] %>% summary
Filtered = intersection_pooled.subtypes[,"data.source"] %>% summary  
Filtered_margin = Filtered_intersection_pooled.subtypes[,"data.source"] %>% summary  
mydata <- data.frame(All,Filtered, Filtered_margin)
newdata <- mydata[order(All),]
@ 



%We choose a cutoff of \Sexpr{sprintf("%0.2f", margin_cutoff)} (corresponding to \Sexpr{ sprintf("%0.2f", margin_scatterplot.df$percent[margin_scatterplot.df$margin == margin_cutoff])}\% of data removed) after which the amount of dataset removed increases drastically and removed the patients that had lower subtype margins in any of the following schemes Konecny, Verhaak or Tothill. The resulting dataset has high subtype concordance as shown in the subtype concordance curves.

%The resulting dataset is as below:
\begin{figure}[H]
<<dataset_barplots, out.width="0.8\\textwidth">>=

barplot(as.matrix(newdata) %>% t, main="HGS sample sizes", 
        beside=TRUE, 
        horiz=TRUE, las=2, 
        col=terrain.colors(3),
        legend=c("All", "Margins Removed", "Concordant Across Subtyping Methods"),
        legend.placement='br'
       )

@
\caption{Barplot showing the total number of samples, number of samples after removing margins, and number of samples that are concordant across methods in each of the datasets we considered.}
\end{figure}


The following are the venndiagrams showing the 3-way concordance of each subtype of the whole dataset versus the filtered dataset. 

<<modified_venn_diagram>>=
draw.triple.venn_adapted <- function (area1, area2, area3, n12, n23, n13, n123, overlay_another = FALSE, overlay_area1=0, overlay_area2=0, overlay_area3=0, overlay_n12=0, overlay_n23=0, overlay_n13=0, overlay_n123=0,category = rep("", 
    3), rotation = 1, reverse = FALSE, euler.d = TRUE, scaled = TRUE, 
    lwd = rep(2, 3), lty = rep("solid", 3), col = rep("black", 
        3), fill = NULL, alpha = rep(0.5, 3), label.col = rep("black", 
        7), cex = rep(1, 7), fontface = rep("plain", 7), fontfamily = rep("serif", 
        7), cat.pos = c(-40, 40, 180), cat.dist = c(0.05, 0.05, 
        0.025), cat.col = rep("black", 3), cat.cex = rep(1, 3), 
    cat.fontface = rep("plain", 3), cat.fontfamily = rep("serif", 
        3), cat.just = list(c(0.5, 1), c(0.5, 1), c(0.5, 0)), 
    cat.default.pos = "outer", cat.prompts = FALSE, rotation.degree = 0, 
    rotation.centre = c(0.5, 0.5), ind = TRUE, sep.dist = 0.05, 
    offset = 0, cex.prop = NULL, print.mode = "raw", sigdigs = 3, 
    direct.area = FALSE, area.vector = 0, ...) 
{
    if (length(category) == 1) {
        cat <- rep(category, 3)
    }
    else if (length(category) != 3) {
        flog.error("Unexpected parameter length for 'category'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'category'")
    }
    if (length(lwd) == 1) {
        lwd <- rep(lwd, 3)
    }
    else if (length(lwd) != 3) {
        flog.error("Unexpected parameter length for 'lwd'", name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'lwd'")
    }
    if (length(lty) == 1) {
        lty <- rep(lty, 3)
    }
    else if (length(lty) != 3) {
        flog.error("Unexpected parameter length for 'lty'", name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'lty'")
    }
    if (length(col) == 1) {
        col <- rep(col, 3)
    }
    else if (length(col) != 3) {
        flog.error("Unexpected parameter length for 'col'", name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'col'")
    }
    if (length(label.col) == 1) {
        label.col <- rep(label.col, 7)
    }
    else if (length(label.col) != 7) {
        flog.error("Unexpected parameter length for 'label.col'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'label.col'")
    }
    if (length(cex) == 1) {
        cex <- rep(cex, 7)
    }
    else if (length(cex) != 7) {
        flog.error("Unexpected parameter length for 'cex'", name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cex'")
    }
    if (length(fontface) == 1) {
        fontface <- rep(fontface, 7)
    }
    else if (length(fontface) != 7) {
        flog.error("Unexpected parameter length for 'fontface'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'fontface'")
    }
    if (length(fontfamily) == 1) {
        fontfamily <- rep(fontfamily, 7)
    }
    else if (length(fontfamily) != 7) {
        flog.error("Unexpected parameter length for 'fontfamily'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'fontfamily'")
    }
    if (length(fill) == 1) {
        fill <- rep(fill, 3)
    }
    else if (length(fill) != 3 & length(fill) != 0) {
        flog.error("Unexpected parameter length for 'fill'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'fill'")
    }
    if (length(alpha) == 1) {
        alpha <- rep(alpha, 3)
    }
    else if (length(alpha) != 3 & length(alpha) != 0) {
        flog.error("Unexpected parameter length for 'alpha'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'alpha'")
    }
    if (length(cat.pos) == 1) {
        cat.pos <- rep(cat.pos, 3)
    }
    else if (length(cat.pos) != 3) {
        flog.error("Unexpected parameter length for 'cat.pos'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.pos'")
    }
    if (length(cat.dist) == 1) {
        cat.dist <- rep(cat.dist, 3)
    }
    else if (length(cat.dist) != 3) {
        flog.error("Unexpected parameter length for 'cat.dist'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.dist'")
    }
    if (length(cat.col) == 1) {
        cat.col <- rep(cat.col, 3)
    }
    else if (length(cat.col) != 3) {
        flog.error("Unexpected parameter length for 'cat.col'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.col'")
    }
    if (length(cat.cex) == 1) {
        cat.cex <- rep(cat.cex, 3)
    }
    else if (length(cat.cex) != 3) {
        flog.error("Unexpected parameter length for 'cat.cex'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.cex'")
    }
    if (length(cat.fontface) == 1) {
        cat.fontface <- rep(cat.fontface, 3)
    }
    else if (length(cat.fontface) != 3) {
        flog.error("Unexpected parameter length for 'cat.fontface'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.fontface'")
    }
    if (length(cat.fontfamily) == 1) {
        cat.fontfamily <- rep(cat.fontfamily, 3)
    }
    else if (length(cat.fontfamily) != 3) {
        flog.error("Unexpected parameter length for 'cat.fontfamily'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter length for 'cat.fontfamily'")
    }
    if (!(class(cat.just) == "list" & length(cat.just) == 3)) {
        flog.error("Unexpected parameter format for 'cat.just'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter format for 'cat.just'")
    }
    else if (!(length(cat.just[[1]]) == 2 & length(cat.just[[2]]) == 
        2 & length(cat.just[[3]]) == 2)) {
        flog.error("Unexpected parameter format for 'cat.just'", 
            name = "VennDiagramLogger")
        stop("Unexpected parameter format for 'cat.just'")
    }
    if (euler.d == FALSE & scaled == TRUE) {
        flog.error("Uninterpretable parameter combination\nPlease set both euler.d = FALSE and scaled = FALSE to force Venn diagrams.", 
            name = "VennDiagramLogger")
        stop("Uninterpretable parameter combination\nPlease set both euler.d = FALSE and scaled = FALSE to force Venn diagrams.")
    }
    if (offset > 1 | offset < 0) {
        flog.error("'Offset' must be between 0 and 1.  Try using 'rotation.degree = 180' to achieve offsets in the opposite direction.", 
            name = "VennDiagramLogger")
        stop("'Offset' must be between 0 and 1.  Try using 'rotation.degree = 180' to achieve offsets in the opposite direction.")
    }
    cat.pos <- cat.pos + rotation.degree
    if (direct.area) {
        areas <- area.vector
        for (i in 1:7) {
            assign(paste("a", i, sep = ""), area.vector[i])
        }
    }
    else {
        a1 <- area1 - n12 - n13 + n123
        a2 <- n12 - n123
        a3 <- area2 - n12 - n23 + n123
        a4 <- n13 - n123
        a5 <- n123
        a6 <- n23 - n123
        a7 <- area3 - n13 - n23 + n123
        areas <- c(a1, a2, a3, a4, a5, a6, a7)
    }
    
    overlay_a1 <- overlay_area1 - overlay_n12 - overlay_n13 + overlay_n123
    overlay_a2 <- overlay_n12 - overlay_n123
    overlay_a3 <- overlay_area2 - overlay_n12 - overlay_n23 + overlay_n123
    overlay_a4 <- overlay_n13 - overlay_n123
    overlay_a5 <- overlay_n123
    overlay_a6 <- overlay_n23 - overlay_n123
    overlay_a7 <- overlay_area3 - overlay_n13 - overlay_n23 + overlay_n123
    overlay_areas <- c(overlay_a1, overlay_a2, overlay_a3, overlay_a4, overlay_a5, overlay_a6, overlay_a7)
    
    
    if (euler.d) {
        special.code <- VennDiagram::decide.special.case(areas)
        if (special.code %in% c("121AO", "100", "033", "011A", 
            "021AA", "022AAOO", "011O", "112AA", "122AAOO", "010", 
            "110", "130", "001", "012AA", "120", "022AAAO", "032", 
            "111A", "023")) {
            if (special.code %in% c("022AAAO", "022AAOO", "023", 
                "032", "120", "121AO", "122AAOO", "130")) {
                f1 <- VennDiagram::draw.sp.case.scaled
            }
            else {
                f1 <- VennDiagram::draw.sp.case.preprocess
            }
            rst <- f1(sp.case.name = special.code, a1 = areas[1], 
                a2 = areas[2], a3 = areas[3], a4 = areas[4], 
                a5 = areas[5], a6 = areas[6], a7 = areas[7], 
                category = category, reverse = reverse, cat.default.pos = cat.default.pos, 
                lwd = lwd, lty = lty, col = col, label.col = label.col, 
                cex = cex, fontface = fontface, fontfamily = fontfamily, 
                cat.pos = cat.pos, cat.dist = cat.dist, cat.col = cat.col, 
                cat.cex = cat.cex, cat.fontface = cat.fontface, 
                cat.fontfamily = cat.fontfamily, cat.just = cat.just, 
                cat.prompts = cat.prompts, fill = fill, alpha = alpha, 
                print.mode = print.mode, sigdigs = sigdigs, ...)
            rst <- VennDiagram::adjust.venn(VennDiagram::rotate.venn.degrees(gList1 = rst, 
                angle = rotation.degree, x.centre = rotation.centre[1], 
                y.centre = rotation.centre[2]), ...)
            if (ind) {
                grid.draw(rst)
            }
            return(rst)
        }
    }
    rotated <- VennDiagram::rotate(areas, category, lwd, lty, 
        col, label.col, cex, fontface, fontfamily, cat.col, cat.cex, 
        cat.fontface, cat.fontfamily, alpha, rotation, reverse, 
        fill)
    for (i in 1:length(areas)) {
        areas[i] <- rotated[[1]][i]
    }
    category <- rotated[[2]]
    lwd <- rotated$lwd
    lty <- rotated$lty
    col <- rotated$col
    label.col <- rotated$label.col
    cex <- rotated$cex
    fontface <- rotated$fontface
    fontfamily <- rotated$fontfamily
    cat.col <- rotated$cat.col
    cat.cex <- rotated$cat.cex
    cat.fontface <- rotated$cat.fontface
    cat.fontfamily <- rotated$cat.fontfamily
    fill <- rotated$fill
    alpha <- rotated$alpha
    areas.error <- c("a1 <- area1 - n12 - n13 + n123", "a2 <- n12 - n123", 
        "a3 <- area2 - n12 - n23 + n123", "a4 <- n13 - n123", 
        "a5 <- n123", "a6 <- n23 - n123", "a7 <- area3 - n13 - n23 + n123")
    for (i in 1:length(areas)) {
        if (areas[i] < 0) {
            flog.error(paste("Impossible:", areas.error[i], "produces negative area"), 
                name = "VennDiagramLogger")
            stop(paste("Impossible:", areas.error[i], "produces negative area"))
        }
    }
    for (i in 1:length(areas)) {
        if (areas[i]) {
            scaled <- FALSE
        }
    }
    is.defaults <- TRUE
    if (is.expression(category)) {
        is.defaults <- FALSE
    }
    if (all(cat.default.pos != "outer", cat.default.pos != "text", 
        !is.defaults, cat.prompts)) {
        flog.info("No default location recognized.  Automatically changing to 'outer'", 
            name = "VennDiagramLogger")
        cat.default.pos <- "outer"
    }
    if (all(cat.default.pos == "outer", !is.defaults, cat.prompts)) {
        flog.info("Placing category labels at default outer locations.  Use 'cat.pos' and 'cat.dist' to modify location.", 
            name = "VennDiagramLogger")
        flog.info(paste("Current 'cat.pos':", cat.pos[1], "degrees,", 
            cat.pos[2], "degrees"), name = "VennDiagramLogger")
        flog.info(paste("Current 'cat.dist':", cat.dist[1], ",", 
            cat.dist[2]), name = "VennDiagramLogger")
    }
    if (all(cat.default.pos == "text", !is.defaults, cat.prompts)) {
        flog.info("Placing category labels at default text locations.  Use 'cat.pos' and 'cat.dist' to modify location.", 
            name = "VennDiagramLogger")
        flog.info(paste("Current 'cat.pos':", cat.pos[1], "degrees,", 
            cat.pos[2], "degrees"), name = "VennDiagramLogger")
        flog.info(paste("Current 'cat.dist':", cat.dist[1], ",", 
            cat.dist[2]), name = "VennDiagramLogger")
    }
    grob.list <- gList()
    if (!exists("overrideTriple")) {
        r1 <- sqrt(100/pi)
        r2 <- r1
        r3 <- r1
    }
    else {
        r1 <- sqrt(area1/pi)
        r2 <- sqrt(area2/pi)
        r3 <- sqrt(area3/pi)
    }
    max.circle.size = 0.2
    shrink.factor <- max.circle.size/r1
    r1 <- r1 * shrink.factor
    r2 <- r2 * shrink.factor
    r3 <- r3 * shrink.factor
    if (!exists("overrideTriple")) {
        a <- find.dist(100, 100, 40) * shrink.factor
        b <- a
        c <- a
    }
    else {
        a <- find.dist(area1, area2, n12) * shrink.factor
        b <- find.dist(area2, area3, n23) * shrink.factor
        c <- find.dist(area1, area3, n13) * shrink.factor
    }
    x.centres <- vector(mode = "numeric", length = 3)
    y.centres <- vector(mode = "numeric", length = 3)
    beta <- (a^2 + c^2 - b^2)/(2 * a * c)
    gamma <- sqrt(1 - beta^2)
    x.centres[1] <- (r1 - r2 - a + 1)/2
    x.centres[3] <- x.centres[1] + c * beta
    y.centres[3] <- (r3 - r1 + 1 - c * gamma)/2
    y.centres[1] <- y.centres[3] + c * gamma
    x.centres[2] <- x.centres[1] + a
    y.centres[2] <- y.centres[1]
    radii <- c(r1, r2, r3)
    for (i in 1:3) {
        grob.list <- gList(grob.list, VennDiagram::ellipse(x = x.centres[i], 
            y = y.centres[i], a = radii[i], b = radii[i], gp = gpar(lty = 0, 
                fill = fill[i], alpha = alpha[i])))
    }
    for (i in 1:3) {
        grob.list <- gList(grob.list, VennDiagram::ellipse(x = x.centres[i], 
            y = y.centres[i], a = radii[i], b = radii[i], gp = gpar(lwd = lwd[i], 
                lty = lty[i], col = col[i], fill = "transparent")))
    }
    new.x.centres <- vector(mode = "numeric", length = 3)
    new.y.centres <- vector(mode = "numeric", length = 3)
    # cell.labels <- areas
    cell.labels <- 
      if (overlay_another) 
        paste0(round( 100*overlay_areas/sum(overlay_areas), 1), "%",
                          "\n","(", round( 100*areas/sum(areas), 1), "%)"
                          )
        
    else 
      paste0(areas," (", round( 100*areas/sum(areas), 1), "%)")
    
    cell.x <- vector(mode = "numeric", length = 7)
    cell.y <- vector(mode = "numeric", length = 7)
    x.cept.12 <- (r1^2 - r2^2 - x.centres[1]^2 + x.centres[2]^2)/(2 * 
        (x.centres[2] - x.centres[1]))
    y.cept.12.1 <- sqrt(r1^2 - (x.cept.12 - x.centres[1])^2) + 
        y.centres[1]
    y.cept.12.2 <- -sqrt(r1^2 - (x.cept.12 - x.centres[1])^2) + 
        y.centres[1]
    theta <- acos((a^2 + c^2 - b^2)/(2 * a * c))
    new.x.centres[3] <- x.centres[1] + c
    l.x.cept.13 <- (r1^2 - r3^2 - x.centres[1]^2 + new.x.centres[3]^2)/(2 * 
        (new.x.centres[3] - x.centres[1]))
    l.y.cept.13.1 <- sqrt(r1^2 - (l.x.cept.13 - x.centres[1])^2) + 
        y.centres[1]
    l.y.cept.13.2 <- -sqrt(r1^2 - (l.x.cept.13 - x.centres[1])^2) + 
        y.centres[1]
    rot <- sqrt(2 * r1^2 - 2 * r1^2 * cos(theta))
    x.cept.13.1 <- l.x.cept.13 + rot * cos(pi/2 - atan((l.y.cept.13.1 - 
        y.centres[1])/(l.x.cept.13 - x.centres[1])) + theta/2)
    x.cept.13.2 <- l.x.cept.13 + rot * cos(pi/2 - atan((l.y.cept.13.2 - 
        y.centres[1])/(l.x.cept.13 - x.centres[1])) + theta/2)
    y.cept.13.1 <- l.y.cept.13.1 - rot * sin(pi/2 - atan((l.y.cept.13.1 - 
        y.centres[1])/(l.x.cept.13 - x.centres[1])) + theta/2)
    y.cept.13.2 <- l.y.cept.13.2 - rot * sin(pi/2 - atan((l.y.cept.13.2 - 
        y.centres[1])/(l.x.cept.13 - x.centres[1])) + theta/2)
    theta <- -acos((a^2 + b^2 - c^2)/(2 * a * b))
    new.x.centres[3] <- x.centres[2] - b
    l.x.cept.23 <- (r2^2 - r3^2 - x.centres[2]^2 + new.x.centres[3]^2)/(2 * 
        (new.x.centres[3] - x.centres[2]))
    l.y.cept.23.1 <- sqrt(r2^2 - (l.x.cept.23 - x.centres[2])^2) + 
        y.centres[2]
    l.y.cept.23.2 <- -sqrt(r2^2 - (l.x.cept.23 - x.centres[2])^2) + 
        y.centres[2]
    rot <- sqrt(2 * r2^2 - 2 * r2^2 * cos(theta))
    x.cept.23.1 <- l.x.cept.23 + rot * cos(pi/2 - atan((y.centres[2] - 
        l.y.cept.23.1)/(x.centres[2] - l.x.cept.23)) + theta/2)
    x.cept.23.2 <- l.x.cept.23 + rot * cos(pi/2 - atan((y.centres[2] - 
        l.y.cept.23.2)/(x.centres[2] - l.x.cept.23)) + theta/2)
    y.cept.23.1 <- l.y.cept.23.1 - rot * sin(pi/2 - atan((y.centres[2] - 
        l.y.cept.23.1)/(x.centres[2] - l.x.cept.23)) + theta/2)
    y.cept.23.2 <- l.y.cept.23.2 - rot * sin(pi/2 - atan((y.centres[2] - 
        l.y.cept.23.2)/(x.centres[2] - l.x.cept.23)) + theta/2)
    m <- (y.cept.23.2 - y.cept.23.1)/(x.cept.23.2 - x.cept.23.1)
    y.sect <- m * (x.cept.12 - x.cept.23.1) + y.cept.23.1
    cell.x[5] <- x.cept.12
    cell.y[5] <- y.sect
    m <- (y.cept.13.2 - y.cept.13.1)/(x.cept.13.2 - x.cept.13.1)
    y0 <- y.centres[2]
    x0 <- x.centres[2]
    b <- y.cept.13.1 - m * x.cept.13.1
    x.sect <- (m * y0 + x0 - m * b)/(m^2 + 1) + sqrt(r2^2 - ((y0 - 
        m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    y.sect <- (m^2 * y0 + m * x0 + b)/(m^2 + 1) + m * sqrt(r2^2 - 
        ((y0 - m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    cell.x[3] <- (x.cept.13.1 + x.sect)/2
    cell.y[3] <- (y.cept.13.1 + y.sect)/2
    m <- (y.cept.23.2 - y.cept.23.1)/(x.cept.23.2 - x.cept.23.1)
    y0 <- y.centres[1]
    x0 <- x.centres[1]
    b <- y.cept.23.1 - m * x.cept.23.1
    x.sect <- (m * y0 + x0 - m * b)/(m^2 + 1) - sqrt(r1^2 - ((y0 - 
        m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    y.sect <- (m^2 * y0 + m * x0 + b)/(m^2 + 1) - m * sqrt(r1^2 - 
        ((y0 - m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    cell.x[1] <- (x.cept.23.1 + x.sect)/2
    cell.y[1] <- (y.cept.23.1 + y.sect)/2
    y.sect <- -sqrt(r3^2 - (x.cept.12 - x.centres[3])^2) + y.centres[3]
    cell.x[7] <- x.cept.12
    cell.y[7] <- (y.cept.12.2 + y.sect)/2
    m <- (y.cept.23.2 - y.cept.23.1)/(x.cept.23.2 - x.cept.23.1)
    y0 <- y.centres[1]
    x0 <- x.centres[1]
    b <- y.cept.23.1 - m * x.cept.23.1
    x.sect <- (m * y0 + x0 - m * b)/(m^2 + 1) + sqrt(r1^2 - ((y0 - 
        m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    y.sect <- (m^2 * y0 + m * x0 + b)/(m^2 + 1) + m * sqrt(r1^2 - 
        ((y0 - m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    cell.x[6] <- (x.cept.23.2 + x.sect)/2
    cell.y[6] <- (y.cept.23.2 + y.sect)/2
    m <- (y.cept.13.2 - y.cept.13.1)/(x.cept.13.2 - x.cept.13.1)
    y0 <- y.centres[2]
    x0 <- x.centres[2]
    b <- y.cept.13.1 - m * x.cept.13.1
    x.sect <- (m * y0 + x0 - m * b)/(m^2 + 1) - sqrt(r2^2 - ((y0 - 
        m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    y.sect <- (m^2 * y0 + m * x0 + b)/(m^2 + 1) - m * sqrt(r2^2 - 
        ((y0 - m * x0 - b)/sqrt(1 + m^2))^2)/sqrt(1 + m^2)
    cell.x[4] <- (x.cept.13.2 + x.sect)/2
    cell.y[4] <- (y.cept.13.2 + y.sect)/2
    y.sect <- sqrt(r3^2 - (x.cept.12 - x.centres[3])^2) + y.centres[3]
    cell.x[2] <- x.cept.12
    cell.y[2] <- (y.cept.12.1 + y.sect)/2
    if (length(cex.prop) > 0) {
        if (length(cex.prop) != 1) 
            flog.error("Value passed to cex.prop is not length 1", 
                name = "VennDiagramLogger")
        stop("Value passed to cex.prop is not length 1")
        func = cex.prop
        if (class(cex.prop) != "function") {
            if (cex.prop == "lin") {
                func = function(x) x
            }
            else if (cex.prop == "log10") {
                func = log10
            }
            else flog.error(paste0("Unknown value passed to cex.prop: ", 
                cex.prop), name = "VennDiagramLogger")
            stop(paste0("Unknown value passed to cex.prop: ", 
                cex.prop))
        }
        maxArea = max(areas)
        for (i in 1:length(areas)) {
            cex[i] = cex[i] * func(areas[i])/func(maxArea)
            if (cex[i] <= 0) 
                stop(paste0("Error in rescaling of area labels: the label of area ", 
                  i, " is less than or equal to zero"))
        }
    }
    processedLabels <- rep("", length(cell.labels))
    if (print.mode[1] == "percent") {
        processedLabels <- paste(signif(cell.labels/sum(cell.labels) * 
            100, digits = sigdigs), "%", sep = "")
        if (isTRUE(print.mode[2] == "raw")) {
            processedLabels <- paste(processedLabels, "\n(", 
                cell.labels, ")", sep = "")
        }
    }
    if (print.mode[1] == "raw") {
        processedLabels <- cell.labels
        if (isTRUE(print.mode[2] == "percent")) {
            processedLabels <- paste(processedLabels, "\n(", 
                paste(signif(cell.labels/sum(cell.labels) * 100, 
                  digits = sigdigs), "%)", sep = ""), sep = "")
        }
    }
    for (i in 1:7) {
        grob.list <- gList(grob.list, textGrob(label = processedLabels[i], 
            x = cell.x[i], y = cell.y[i], gp = gpar(col = label.col[i], 
                cex = cex[i], fontface = fontface[i], fontfamily = fontfamily[i])))
    }
    text.location.mapping <- c(1, 3, 7)
    for (i in 1:3) {
        if ("outer" == cat.default.pos) {
            this.cat.pos <- find.cat.pos(x = x.centres[i], y = y.centres[i], 
                pos = cat.pos[i], dist = cat.dist[i], r = radii[i])
        }
        else if ("text" == cat.default.pos) {
            this.cat.pos <- find.cat.pos(x = cell.x[text.location.mapping[i]], 
                y = cell.y[text.location.mapping[i]], pos = cat.pos[i], 
                dist = cat.dist[i])
        }
        else {
            flog.error("Invalid setting of cat.default.pos", 
                name = "VennDiagramLogger")
            stop("Invalid setting of cat.default.pos")
        }
        grob.list <- gList(grob.list, textGrob(label = category[i], 
            x = this.cat.pos$x, y = this.cat.pos$y, just = cat.just[[i]], 
            gp = gpar(col = cat.col[i], cex = cat.cex[i], fontface = cat.fontface[i], 
                fontfamily = cat.fontfamily[i])))
    }
    grob.list <- VennDiagram::adjust.venn(VennDiagram::rotate.venn.degrees(gList1 = grob.list, 
        angle = rotation.degree, x.centre = rotation.centre[1], 
        y.centre = rotation.centre[2]), ...)
    if (ind) {
        grid.draw(grob.list)
    }
    return(grob.list)
}
@

<<venn_setup>>=

# function to convert overlaps to area - this seems to be missing in the venn diagram package 
get_areas_from_overlaps <- function(overlaps){
  area1 = overlaps[[5]] + overlaps[[3]] + overlaps[[2]] + overlaps[[1]]
  area2 = overlaps[[6]] + overlaps[[4]] + overlaps[[2]] + overlaps[[1]] 
  area3 = overlaps[[7]] + overlaps[[4]] + overlaps[[3]] + overlaps[[1]] 
  n12 = overlaps[[2]] + overlaps[[1]]
  n23 = overlaps[[4]] + overlaps[[1]] 
  n13 = overlaps[[3]] + overlaps[[1]] 
  n123 = overlaps[[1]]
  c(area1,area2,area3,n12,n23,n13,n123)
}


 # the overlaps obtained by get_overlap function are numbers of non-intersecting regions of the venn - they had to be computed for the whole areas again for strange reason - maybe there is a simpler function in the VennDiagram that would replace parts of the below function
get_venn_margin_subtype <- function(margin,subtype_order, overlay_another = FALSE, margin_overlay = 1500){
    margin_areas = get_overlaps_margin[[margin]][[subtype_order]]$lengths %>% get_areas_from_overlaps
    overlay_margin_areas = 
      if (overlay_another)
      get_overlaps_margin[[margin_overlay]][[subtype_order]]$lengths %>% get_areas_from_overlaps else c(0,0,0,0,0,0,0)
 #dev.control('enable')   
    venn_dia <- 
      draw.triple.venn_adapted(area1 = margin_areas[[1]], 
                                area2 = margin_areas[[2]], 
                                area3 = margin_areas[[3]], 
                                n12 = margin_areas[[4]], 
                                n23 = margin_areas[[5]], 
                                n13 = margin_areas[[6]], 
                                n123 = margin_areas[[7]], 
                                overlay_another = overlay_another,
                                overlay_area1 = overlay_margin_areas[[1]], 
                                overlay_area2 = overlay_margin_areas[[2]], 
                                overlay_area3 = overlay_margin_areas[[3]], 
                                overlay_n12 = overlay_margin_areas[[4]], 
                                overlay_n23 = overlay_margin_areas[[5]], 
                                overlay_n13 = overlay_margin_areas[[6]], 
                                overlay_n123 = overlay_margin_areas[[7]], 
                                category = subtype.names[1:3], filename = NULL, 
                                #fill = c("blue", "yellow", "green")   
                                fill = c("gold", "orange", "orchid3"), margin = 0.05, lty = 0
                                
    )

  }
@


\begin{figure}[H]
<<Subtype_venn_diagrams, fig.keep ='last', fig.width=5, fig.height=5>>=

draw_venn <- function (margin,margin_overlay, subtype_order){
  q <- get_venn_margin_subtype(margin,subtype_order, overlay_another = TRUE, margin_overlay)   
  grid.arrange(
    gTree(children = q),
    top=subtypes[[2]][[subtype_order]]
  )
}

draw_venn_formargin <- function (margin,margin_overlay){
    dv1 <- draw_venn(margin,margin_overlay,1)
    dv2 <- draw_venn(margin,margin_overlay,2)
    dv3 <- draw_venn(margin,margin_overlay,3)
    dv4 <- draw_venn(margin,margin_overlay,4)
    grid.arrange(dv1,dv2,dv3,dv4,top="Overlap in non-marginal cases (all cases)", ncol = 2)
}




margin_overlay_cutoff = ceiling(margin_cutoff*3000) %>% as.integer

draw_venn_formargin(1,margin_overlay_cutoff)
@

\caption{Venn diagrams showing the percentages of patients classified under each subtype by each method after removing 85\% of patients with the least distinct subtypes, the numbers in parenthesis are the percentages before filtering.}
\end{figure}


Below is a summary of the consensus analysis in the form of a figure in the main manuscript:


% Main Figures of the manuscript
%figure 1 - pairwise concordance, venn_diagram, scatterplot 
\begin{figure}[H]
<<Figure1-ConsensusAnalysis, fig.keep ='last', fig.width=10, fig.height=10, cache=FALSE>>=
venn_dia <- draw_venn_formargin(1,margin_overlay_cutoff)
# Two-way Concordances
Pane_A <- grid.arrange(
contingency.plots[[1]],
contingency.plots[[3]],
contingency.plots[[5]], top = "A.", ncol = 1)

# Margins Versus Two-way and three-way Concordances
Pane_B <- grid.arrange(
# margin.scatterplots[[1]],
# margin.scatterplots[[2]],
# margin.scatterplots[[3]], 
scatterplots.combined, top = "B.")

Pane_C <- grid.arrange( 
subtype_scatterplots, top = "C.")

# Venn Diagrams showing the number of patients in each subtype stratified by the methods
Pane_D <- grid.arrange(
venn_dia, top = "D.", ncol = 1)


grid.arrange(
Pane_A, Pane_B,  Pane_C, Pane_D, layout_matrix = matrix(c(1,1,1,1,2,2,4,4,3,3,4,4), nrow = 4, byrow = FALSE), widths=c(8,10,10), heights = c(10,10,10,10)
)


@
\caption{Concordance Analysis. A. Contingency table showing concordance of subtypes while comparing the methods pairwise B. Pairwise concordance between the methods C. three-way overall concordance between the methods and that of the individual subtypes D. Venn diagrams showing the percentages of patients classified under each subtype by each method after removing 85\% of patients with the least distinct subtypes, the numbers in parenthesis are the percentages before filtering.  
}
\end{figure}

%\pagebreak

\section{Survival Analysis}
<<Pooled_survival_plot, fig.height=12, out.width="0.8\\textwidth">>=
# layout(matrix(c(1,1,2,2,3,3,0,4,4,5,5,0), nrow = 2, byrow = TRUE))
layout(matrix(c(1,2,3,4,5,6), nrow = 3, byrow = TRUE))
#par(mfrow=c(2,2))
#par(mar=c(5,1,0,1))
par(mar=c(5.1, 8, 4.1, 2.1))
#for(subtype.name in subtype.names[1:3]) {
for(subtype.name in subtype.names) {
  #pdf(paste0(subtype.name, "_pooled_survival.pdf"), width=5, height=5)
  par(mar=c(5.1, 5, 4.1, 2.1))
  survival.df <- pooled.subtypes.survival
  survival.df$groups <- survival.df[,subtype.name]
  
  pval <- summary(coxph(surv.obj ~ groups + strata(data.source), survival.df))$sctest["pvalue"]
  
  hr.out <- survcomp::hazard.ratio(x=survival.df$groups, surv.time=survival.df$years_to_death, surv.event=survival.df$vital_status, strat=survival.df$data.source)
  text <- ""
  text <- paste0(text, "n = ", nrow(survival.df), "\n")
  if(length(hr.out$hazard.ratio) == 1) {
    text <- paste0(text, sprintf("HR: %.3f (%.3f-%.3f)\n", hr.out$hazard.ratio, hr.out$lower, hr.out$upper), sprintf("Logrank p = %.1E", pval))
  } else {
    for(i in 1:length(hr.out$hazard.ratio)) {
      text <- paste0(text, sprintf("HR %s: %.3f (%.3f-%.3f)\n", levels(survival.df$groups)[i+1], hr.out$hazard.ratio[i], hr.out$lower[i], hr.out$upper[i]))
    }
     text <- paste0(text, sprintf("Logrank p = %.1E", pval))
  }
  cols <- 1:4
  if(subtype.name == "Bentink") {
    cols <- c("orange", "blue")
  }
  title <- subtype.name
  if(title == "Verhaak") {
    title <- "TCGA / Verhaak"
  }
  if(title == "Helland") {
    title <- "Tothill / Helland"
  }
  km.coxph.plot(surv.obj ~ groups, survival.df, x.label="Time (years)", y.label = "Overall Survival", main.title="", show.n.risk = FALSE, n.risk.step=2, leg.text = levels(survival.df$groups), leg.pos="topright", leg.inset=0, leg.bty="n", n.risk.cex=0.85, cex=0.4, o.text="", .col=cols, cex.lab=1.5)
  title(title, cex.main=2)
  text(0,0.05, text, cex=0.85, pos=4)
  #dev.off()
}

##########################
## below is the survival plot for the patients with classified as same subtypes across the methods 
survival_filtered_all.df <- intersection_pooled.subtypes.survival
  survival_filtered_all.df$groups <- 
  survival_filtered_all.df[,"Verhaak"] 
# since we name the subtypes of the filtered set to that of Verhaak
  
  pval <- summary(coxph(surv.obj ~ groups + strata(data.source), survival_filtered_all.df))$sctest["pvalue"]
  
  hr.out <- survcomp::hazard.ratio(x=survival_filtered_all.df$groups, surv.time=survival_filtered_all.df$years_to_death, surv.event=survival_filtered_all.df$vital_status, strat=survival_filtered_all.df$data.source)
  text <- ""
  text <- paste0(text, "n = ", nrow(survival_filtered_all.df), "\n")
  if(length(hr.out$hazard.ratio) == 1) {
    text <- paste0(sprintf("HR: %.3f (%.3f-%.3f)\n", hr.out$hazard.ratio, hr.out$lower, hr.out$upper), sprintf("Logrank p = %.1E", pval))
  } else {
    for(i in 1:length(hr.out$hazard.ratio)) {
      text <- paste0(text, sprintf("HR %s: %.3f (%.3f-%.3f)\n", levels(survival_filtered_all.df$groups)[i+1], hr.out$hazard.ratio[i], hr.out$lower[i], hr.out$upper[i]))
    }
     text <- paste0(text, sprintf("Logrank p = %.1E", pval))
  }
  cols <- 1:4
  
  title <- "Concordantly Classified Cases"
  
  km.coxph.plot(surv.obj ~ groups, survival_filtered_all.df, x.label="Time (years)", y.label = "Overall Survival", main.title="", show.n.risk = FALSE, n.risk.step=2, leg.text = levels(survival_filtered_all.df$groups), leg.pos="topright", leg.inset=0, leg.bty="n", n.risk.cex=0.85, cex=0.4, o.text="", .col=cols, cex.lab=1.5)
  title(title, cex.main=2)
  text(0,0.05, text, cex=0.85, pos=4)

################

## below is the survival plot AFTER removing the patients with low margin 
survival_filtered.df <- Filtered_intersection_pooled.subtypes.survival
  survival_filtered.df$groups <- 
  survival_filtered.df[,"Verhaak"] 
# since we name the subtypes of the filtered set to that of Verhaak
  
  pval <- summary(coxph(surv.obj ~ groups + strata(data.source), survival_filtered.df))$sctest["pvalue"]
  
  hr.out <- survcomp::hazard.ratio(x=survival_filtered.df$groups, surv.time=survival_filtered.df$years_to_death, surv.event=survival_filtered.df$vital_status, strat=survival_filtered.df$data.source)
  
  text <- ""
  text <- paste0(text, "n = ", nrow(survival_filtered.df), "\n")
  if(length(hr.out$hazard.ratio) == 1) {
    text <- paste0(sprintf("HR: %.3f (%.3f-%.3f)\n", hr.out$hazard.ratio, hr.out$lower, hr.out$upper), sprintf("Logrank p = %.1E", pval))
  } else {
    for(i in 1:length(hr.out$hazard.ratio)) {
      text <- paste0(text, sprintf("HR %s: %.3f (%.3f-%.3f)\n", levels(survival_filtered.df$groups)[i+1], hr.out$hazard.ratio[i], hr.out$lower[i], hr.out$upper[i]))
    }
     text <- paste0(text, sprintf("Logrank p = %.1E", pval))
  }
  cols <- 1:4
  
  title <- "Filtered (after margins)"
  
  km.coxph.plot(surv.obj ~ groups, survival_filtered.df, x.label="Time (years)", y.label = "Overall Survival", main.title="", show.n.risk = FALSE, n.risk.step=2, leg.text = levels(survival_filtered.df$groups), leg.pos="topright", leg.inset=0, leg.bty="n", n.risk.cex=0.85, cex=0.4, o.text="", .col=cols, cex.lab=1.5)
  title(title, cex.main=2)
  text(0,0.05, text, cex=0.85, pos=4)
  @


%\pagebreak
% Hazard Ratio vs % of dataset removed for three subtypes (all in one plot) added by Lavanya Kannan

<<HR, echo = TRUE, results='asis'>>=

coxph.model = coxph(surv.obj ~ groups + strata(data.source), survival_filtered.df)
fit = summary(coxph.model)
print(xtable(fit$conf.int), include.rownames=FALSE)
@ 
Interestingly, the survival curves of the first three risky subtypes are more relatively more risky in the filtered dataset.  




<<hr_plots, out.width="0.8\\textwidth">>=
high.risk.group <- function(subtype.order){
  if (subtype.order == 3) subtypes[[subtype.order]][3:4] else subtypes[[subtype.order]][2:4]
}

get_hr <- function (margin, subtype.order) {
  subtype.name <- subtype.names[[subtype.order]]
  # For each margin, extract the dataset 
  #dataset_ids = lapply(1:4, function (i) {get_overlaps(100*(1 - margin), only.survival = TRUE)[[i]]$parts[[1]]}) %>% unlist
  dataset_ids = get_marginal_data_top(100*(1 - margin),subtype.name, only.survival=TRUE) %>% row.names
  Filtered_intersection_margin = pooled.subtypes.survival[dataset_ids,] 
  survival_filtered_margin.df <- Filtered_intersection_margin
  survival_filtered_margin.df$groups <- survival_filtered_margin.df[,subtype.name] 
  survival_filtered_margin.df$high.risk <- survival_filtered_margin.df$groups 
  high.risk <- high.risk.group(subtype.order)
  low.risk <- setdiff(subtypes[[subtype.order]],high.risk)   
  for(i in seq_along(high.risk)) 
   survival_filtered_margin.df$high.risk <- 
   gsub(high.risk[i], "b", survival_filtered_margin.df$high.risk, fixed = TRUE)
  for(i in seq_along(low.risk)) 
   survival_filtered_margin.df$high.risk <- 
   gsub(low.risk[i], "a", survival_filtered_margin.df$high.risk, fixed = TRUE)
  
  
  # fit the coxph model
  # coxph.model = coxph(surv.obj ~ groups, survival_filtered_margin.df)
  coxph.model = coxph(surv.obj ~ high.risk + strata(data.source), survival_filtered_margin.df)
  fit = summary(coxph.model)
  # extract the first column which corresponds to the HR of the three subtypes; 3rd and the 4th column correspond to CI
  fit$conf.int[,c(1,3,4)]  
}

xvals <- seq(0, 0.75, length.out = 2250)

all_hrs_CI <- function (subtype.order) lapply(xvals,function (x) get_hr(x,subtype.order))
all_hrs_CI_subtypes <- lapply(1:3, all_hrs_CI)
extract_hr <- function (all_hrs_CI_subtype) {lapply(1:2250,function (i) all_hrs_CI_subtype[[i]][[1]]) %>% unlist}
extract_lower_CI <- function (all_hrs_CI_subtype) {lapply(1:2250,function (i) all_hrs_CI_subtype[[i]][[2]]) %>% unlist}
extract_upper_CI <- function (all_hrs_CI_subtype) {lapply(1:2250,function (i) all_hrs_CI_subtype[[i]][[3]]) %>% unlist}
@
 
<<HR_plots>>=
get_hr_plot <- function (subtype.order) { 
# ss = smooth.spline(xvals[1:2250], extract_hr(all_hrs_CI_subtypes[[subtype.order]]))
ss_l = smooth.spline(xvals[1:2250], extract_lower_CI(all_hrs_CI_subtypes[[subtype.order]]))
ss_u = smooth.spline(xvals[1:2250], extract_upper_CI(all_hrs_CI_subtypes[[subtype.order]]))
hrplot.df <- data.frame(margin = xvals[1:2250], percent = percent[1:2250],hr = extract_hr(all_hrs_CI_subtypes[[subtype.order]]), lower = ss_l$y, upper = ss_u$y)
#                         
#  
# hrplot.df <- data.frame(margin = xvals[1:2250], percent = percent[1:2250],hr = extract_hr(all_hrs_CI_subtypes[[subtype.order]]))
low.risk.group = setdiff(subtypes[[subtype.order]],high.risk.group(subtype.order)) 
ggplot(hrplot.df, aes(y=hr, x = percent), colour = "Hazard Ratio") + geom_point(size=3) + geom_line(size=3) + theme_bw() + xlab("Percentage of dataset removed") + ylab("Hazard Ratio") + ylim(1, 2.5) + ggtitle(paste("Hazard Ratio w.r.t. less risky subtypes ", paste(low.risk.group,collapse=" "))) + geom_line(aes(y = lower)) + geom_line(aes(y = upper))

# ggplot(hrplot.df, aes(y=hr, x = percent), colour = "Hazard Ratio") + geom_point(size=3) + geom_line(size=3) + theme_bw() + xlab("Percentage of dataset removed") + ylab("Hazard Ratio") + ylim(1, 2.5) + ggtitle(paste("Hazard Ratio w.r.t. less risky subtypes ", paste(low.risk.group,collapse=" ")))
}

grid.arrange(get_hr_plot(1), get_hr_plot(2), get_hr_plot(3),ncol=1)
@

% Figure 2
<<Figure2-SurvivalAnalysis, fig.keep ='last', fig.width=10, fig.height=10, cache=FALSE>>=
survival.df <- pooled.subtypes.survival

get_survival_curve <- function (subtype.order) {
  subtype.name <- subtype.names[[subtype.order]]
  survival.df$groups <- survival.df[,subtype.name]
  
  pval <- summary(coxph(surv.obj ~ groups + strata(data.source), survival.df))$sctest["pvalue"]
  
  hr.out <- survcomp::hazard.ratio(x=survival.df$groups, surv.time=survival.df$years_to_death, surv.event=survival.df$vital_status, strat=survival.df$data.source)
  text <- ""
  text <- paste0(text, "n = ", nrow(survival.df), "\n")
  if(length(hr.out$hazard.ratio) == 1) {
    text <- paste0(text, sprintf("HR: %.2f (%.2f-%.2f)\n", signif(hr.out$hazard.ratio,2), signif(hr.out$lower, hr.out$upper,2)), sprintf("Logrank p = %.1E", pval))
  } else {
    for(i in 1:length(hr.out$hazard.ratio)) {
      text <- paste0(text, sprintf("HR %s: %.2f (%.2f-%.2f)\n", levels(survival.df$groups)[i+1], signif(hr.out$hazard.ratio[i],2), signif(hr.out$lower[i],2), signif(hr.out$upper[i],2)))
    }
     text <- paste0(text, sprintf("Logrank p = %.1E", pval))
  }
  cols <- 1:4
  if(subtype.name == "Bentink") {
    cols <- c("orange", "blue")
  }
  title <- subtype.name
  if(title == "Verhaak") {
    title <- "TCGA / Verhaak"
  }
  if(title == "Helland") {
    title <- "Tothill / Helland"
  }
  ss <- survfit(surv.obj ~ groups, data = survival.df) 
  grob <- grobTree(textGrob(text, x=0.02,  y=0.2, hjust=0,
  gp=gpar(col="black", fontsize=10, fontface="italic")))
  ggsurv(ss, plot.cens = FALSE, main = subtype.name, back.white = TRUE) + theme(legend.direction='horizontal',legend.box='horizontal',legend.position = c(0.55, 0.92), legend.title=element_blank())  + xlab("Time (years)") + annotation_custom(grob)
  
}


Pane_2_A <- grid.arrange(get_survival_curve(1), get_survival_curve(2), get_survival_curve(3),ncol=1,top = "A.")
Pane_2_B <- grid.arrange(get_hr_plot(1), get_hr_plot(2), get_hr_plot(3),ncol=1,
top = "B.")

Fig_2 <-  grid.arrange(Pane_2_A, Pane_2_B,ncol=2)
@ 

<<marginal_dataset>>=
BigDF = pooled.subtypes
SmallDF = Filtered_intersection_pooled.subtypes
marginal_dataset = BigDF[ !(row.names(BigDF) %in% row.names(SmallDF)), ]
@


%\section{Prediction of the patients that are removed into combination of subtypes}
%Below is our prediction of combinations of subtypes in the remaining of the \Sexpr{(length(row.names(marginal_dataset)))} patients that were removed. The subtypes under different algorithms are mapped to the Varhaak subtypes using high concordance. The frequency of each combination of subtypes in the dataset is given below.  

<<marginal_dataset_classification, results='asis', eval=FALSE>>=
levels(marginal_dataset$"Konecny") <- subtypes[[2]]
levels(marginal_dataset$"Helland") <- subtypes[[2]]
subtype_combinations = 
lapply(1:length(row.names(marginal_dataset)), 
       function (i) 
        marginal_dataset[i,subtype.names[1:3]] %>% as.numeric %>% unique %>% sort
       ) 
unique_combinations = subtype_combinations %>% unique
sorted_unique_comb = unique_combinations[order(sapply(unique_combinations,'[[',1))]
map_comb = sapply(sorted_unique_comb,
                  function (i) {subtypes[[2]][i]}
                  )


## function to check if two vectors with unique elements and sorted are the same
vecMatch <- function(x, want) {
    isTRUE(all.equal(x, want))
}

which_combinations = 
lapply(1:length(row.names(marginal_dataset)), 
       function (i) 
        sapply(sorted_unique_comb, vecMatch, subtype_combinations[[i]]) %>% which 
       ) %>% unlist

summary_comb <- as.data.frame(table(which_combinations))
summary_c <- summary_comb[with(summary_comb,order(Freq)),]
row.names(summary_c) <- 
  sapply(map_comb, function (s) paste(s,collapse=" "))[summary_c[,1]]

print(xtable(summary_c[-1]), include.rownames=TRUE)
@

\section{Subtype-Specific Concordance}

<<best_method>>=
# For each classifier and for each margin, find the proportion of each subtype that the classifier identifies. 
methods = 1:3
margin_vals <- seq(100, 0, length.out = 3000)

get_patients_method <- 
  function(subtype_order,margin_percent)
    lapply(1:3, function(subtype.method) get_subtype_patients(subtype_order,margin_percent, subtype.method))

get_patients_marginpercent_method <- 
  function (subtype_order)
lapply(1:3000, function (index)
get_patients_method(subtype_order,margin_vals[[index]]))

get_subtype_patients_marginpercent_method <-
  lapply(1:4, get_patients_marginpercent_method)

get_overlaps_for <- function(index,subtype.method,subtype_order)
get_overlaps(margin_vals[[index]],methods[!methods==subtype.method])[[subtype_order]]$lengths[[3]] 


get_two_way_overlaps <-
  function(subtype.method, go)
  {
    if (subtype.method == 3) {go[[1]] + go[[2]]}
    else {
      if (subtype.method == 2) {go[[1]] + go[[3]]}
      else {go[[1]] + go[[4]]}
    }
  }


find_proportion <- function(subtype.method, subtype_order, index, compare = c("self", "other.two", "all")){
  go <- get_overlaps_margin[[index]][[subtype_order]]$lengths 
    if (compare == "self") 
  {     
    go[[1]]/length(get_subtype_patients_marginpercent_method[[subtype_order]][[index]][[subtype.method]] %>% unlist)
  }
  else if (compare == "other.two")
   go[[1]]/get_two_way_overlaps(subtype.method,go)

    else go[[1]]/sum(go[1:4]) # not sure what to use

}

get_concordance <- function(subtype.method,subtype_order,compare = c("self", "other.two", "all")){
 
  lapply(# margin_vals[1:1500],
       1:3000,
       function (m_v) find_proportion(subtype.method,subtype_order, m_v, compare)) %>% unlist

}

get_concordance_all_subtypes <- function(subtype.method, compare = c("self", "other.two", "all"))
  lapply(1:4, function (i) get_concordance(subtype.method,i, compare))

get_concordance_all_methods <- function(subtype_order, compare = c("self", "other.two", "all"))
  lapply(1:3, function (method) get_concordance(method,subtype_order, compare))

@

The first set of plots give concordance of the dataset at various levels of margins removed (i.e., proportion of patients classified as the same subtype across the different methods) subtype patients classified within each method. The second set of plots give the concordance of the dataset at various levels of margins removed with the subtype patients not classified under the given method, but is classified as the same given subtype under the other two methods.



<<get_best_method_plots, fig.width=15, fig.height=4>>=
get_method_concordance <- function (subtype.method, compare = c("self", "other.two", "all")) {
sc = get_concordance_all_subtypes(subtype.method,compare)
 smc.df <- data.frame( percent = percent, IMR = sc[[1]], DIF= sc[[2]], PRO = sc[[3]], MES = sc[[4]])
 smc.df[is.na(smc.df)] <- NA 
 smc.df <- na.omit(smc.df)

smc_long.df <- melt(smc.df, id = "percent")                      

txt <- if (compare == "self") "within the method" else 
  if (compare == "other.two") "under the other two methods" else "all the methods"
ggplot(smc_long.df, aes(x = percent, y=value, colour=variable)) + scale_colour_manual(values=c("black", "red","green","blue")) + geom_line() + theme_bw() + xlab("Percentage of dataset removed") + ylab(paste0("Concordance with patients ", txt)) + ylim(0, 1) + ggtitle(paste0("Concordance of method ", subtype.names[[subtype.method]])) 
}

grid.arrange(grobs = lapply(1:3,get_method_concordance), ncol = 3)
@

<<concordance_plots_2, fig.width=15, fig.height=4>>=
grid.arrange(grobs = lapply(1:3,function (i) get_method_concordance(i, compare = "other.two")), ncol = 3)

@


In the below plots, we can see how the concordance rises for each subtype as the marginal datasets are removed, also stratified by each individual method. Each subtype is labelled by the name provied by Verhaak et al.

<<subtype_concordance, out.width="0.8\\textwidth">>= 
get_subtype_concordance <- function (subtype_order, compare = c("self", "other.two", "all")) {
concordance <- lapply(1:3000, function(i) {
  go <- get_overlaps_margin[[i]][[subtype_order]]$lengths  
  go[[1]]/sum(go)  
  }) %>% as.numeric
sc = get_concordance_all_methods(subtype_order,compare)

 smc.df <- data.frame( percent = percent, All = concordance, Konecny = sc[[1]], Varhaak= sc[[2]], Helland = sc[[3]])
 smc.df[is.na(smc.df)] <- NA 
 smc.df <- na.omit(smc.df)
 smc_long.df <- melt(smc.df, id = "percent")                      
 

ggplot(smc_long.df, aes(x = percent, y=value, colour=variable)) + scale_colour_manual(values=c("black", "red","green","blue")) + geom_line() + theme_bw() + xlab("Percentage of dataset removed") + ylab("Concordance") + ylim(0, 1) + ggtitle(paste0("Concordance of subtype ", subtypes[[2]][[subtype_order]])) + theme(legend.title=element_blank()) + theme(legend.position="top")
}


## combined plot, shared legend from https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs
grid_arrange_shared_legend <- function(...) {
    plots <- list(...)
    g <- ggplotGrob(plots[[1]] + theme(legend.position="bottom"))$grobs
    legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
    lheight <- sum(legend$height)
    grid.arrange(
        do.call(arrangeGrob, lapply(plots, function(x)
            x + theme(legend.position="none"))),
        legend,
        ncol = 1,
        heights = unit.c(unit(1, "npc") - lheight, lheight))
}
@

<<margin.scatterplots_for_subtypes, out.width="0.8\\textwidth">>=
grid_arrange_shared_legend(get_subtype_concordance(1), get_subtype_concordance(2), get_subtype_concordance(3), get_subtype_concordance(4))
@

<<pairwise_contingency>>=
margin.scatterplots_pairwise <- 
    apply(pair.matrix[,c(1,3,5)], 2, function(subtype.name.pair) {
    margins.1 <- pooled.subtypes[,paste0(subtype.name.pair[1], ".margins")]
    margins.2 <- pooled.subtypes[,paste0(subtype.name.pair[2], ".margins")]
    
    margins.1 <- ecdf(margins.1)(margins.1)
    margins.2 <- ecdf(margins.2)(margins.2)
  
    xvals <- seq(0, 1, length.out = 3000)
    concordance <- sapply(xvals, function(x) {
      margin.boolean <- margins.1 > x & margins.2 > x
      contingency.matrix <- as.matrix(table(pooled.subtypes[,subtype.name.pair[1]][margin.boolean],pooled.subtypes[,subtype.name.pair[2]][margin.boolean]))
      sum(diag(contingency.matrix)) / sum(contingency.matrix)
    })
 # compare with the method that is not in the pair
    other.method = setdiff(subtype.names[1:3],subtype.name.pair)
    subtype.method = which(subtype.names[1:3] == other.method)
    sc = get_concordance_all_subtypes(subtype.method, compare = "other.two")
 
   smc_conc.df <- data.frame( percent = percent, Pairwise=concordance, IMR= sc[[1]], DIF = sc[[2]], PRO= sc[[3]], MES = sc[[4]])
 smc_conc.df[is.na(smc_conc.df)] <- NA 
 smc_conc.df <- na.omit(smc_conc.df)

smc_c.df <- na.omit(smc_conc.df)
  smc_c_long.df <- melt(smc_c.df, id = "percent")   %>% na.omit         
   ggplot(smc_c_long.df) + geom_line(aes(x=percent, y=value, colour=variable, size = variable)) + scale_size_manual(values=c(4,0.5,0.5,0.5,0.5)) + scale_colour_manual(values=c("black", "red","green","blue","violet")) + theme_bw() + xlab("Percentage of dataset removed") + ylab("Concordance") + ggtitle(paste0("Proportions of 3-way in ", subtype.name.pair[1], " and ", subtype.name.pair[2])) + ylim(0, 1) 

  })

#grid.arrange(grobs = margin.scatterplots_pairwise,ncol = 3, widths=c(6,6,6), heights=c(6,6,6))

grid_arrange_shared_legend(margin.scatterplots_pairwise[[1]],margin.scatterplots_pairwise[[2]],margin.scatterplots_pairwise[[3]],ncol = 3)
@