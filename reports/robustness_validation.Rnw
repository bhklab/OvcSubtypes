

<<load_data_from_files>>=
load("esets.not.rescaled.classified.RData")

# These are the dataset names with TCGA RNASeq removed
dataset.names <- names(esets.not.rescaled.classified)

clustering.subtypes <- list()

for(dirname in c("konecny_nmf_4", "tcga_nmf_4", "tothill_kmeans_4")) {
  cluster.classes <- list()
  for(current.eset.name in dataset.names) {
    cluster.classes[[current.eset.name]] <- list()
    filenames <- Sys.glob(paste0("apr12clusters/", dirname, "/", current.eset.name, "_*_classes.txt"))
    for(filename in filenames) {
      cluster.classes[[current.eset.name]][[length(cluster.classes[[current.eset.name]])+1]] <- scan(filename, what=character(0))
    }
  }
  clustering.subtypes[[dirname]] <- cluster.classes
}


classifier.subtypes <- lapply(c("Konecny.subtypes", "Verhaak.subtypes", "Helland.subtypes"), function(subtype.colname) {
  subtype.classes <- list()
  for(current.eset.name in dataset.names) {
    subtype.classes[[current.eset.name]] <- as.character(pData(esets.not.rescaled.classified[[current.eset.name]])[,subtype.colname])
  }
  return(subtype.classes)
})

names(classifier.subtypes) <- c("Konecny", "Verhaak", "Helland")

# Remove clustering/classification subtypes performed on the original dataset
clustering.subtypes$tcga_nmf_4$TCGA <- NULL
clustering.subtypes$tothill_kmeans_4$GSE9891 <- NULL
classifier.subtypes$Verhaak$TCGA <- NULL
classifier.subtypes$Helland$GSE9891 <- NULL

getAdjacencyMatrix <- function(classes) {
  adj.matrix <- matrix(NA, nrow=length(classes), ncol=length(classes))
	for(i in 1:(length(classes)-1)) {
		for(j in (i+1):length(classes)) {
			if(classes[i] == classes[j]) { adj.matrix[i,j] <- adj.matrix[j,i] <- 1 } else { adj.matrix[i,j] <- adj.matrix[j,i] <- 0 }
		}
	}
  return(adj.matrix)
}

getMeanAdjMatrices <- function(configs.to.keep) {
  cluster.class.list.tokeep <- cluster.class.list[configs.to.keep]
  lapply(names(cluster.class.list.tokeep[[1]]), function(dataset.name) {
  mean.adj.matrix <- matrix(0, nrow=length(cluster.class.list.tokeep[[1]][[dataset.name]]), ncol=length(cluster.class.list.tokeep[[1]][[dataset.name]]))
  total <- 0
  for(cluster.config.index in 1:length(cluster.class.list.tokeep)) {
    total <- total + 1
    cluster.classes <- cluster.class.list.tokeep[[cluster.config.index]]
    for(i in 1:(length(cluster.classes[[dataset.name]])-1)) {
      for(j in (i+1):length(cluster.classes[[dataset.name]])) {
        mean.adj.matrix[i,j] <- mean.adj.matrix[i,j] + (cluster.classes[[dataset.name]][i] == cluster.classes[[dataset.name]][j])
        mean.adj.matrix[j,i] <- mean.adj.matrix[j,i] + (cluster.classes[[dataset.name]][i] == cluster.classes[[dataset.name]][j])
      }
    }
  }
  mean.adj.matrix <- mean.adj.matrix / total
  diag(mean.adj.matrix) <- NA
  names(mean.adj.matrix) <- names(cluster.class.list[[1]])
  return(mean.adj.matrix)
})
}

#cluster.adjacency.list <- lapply(cluster.class.list, function(cluster.classes) {
#  lapply(cluster.classes, getAdjacencyMatrix)
#})

#cluster.adjacency.means <- do.call(function(x,y) {
#  for(i in 1:length(x)) sum(x[[i]], y[[i]], na.rm=TRUE)
#}, cluster.adjacency.list)

getMeanPairwiseSimilarityMeasure <- function(class.list, metricFunction) {
  out.vals <- c()
  for(i in 1:(length(class.list) - 1)) {
    for(j in (i+1):length(class.list)) {
      vals <- sapply(1:length(class.list[[i]]), function(x) metricFunction(class.list[[i]][[x]], class.list[[j]][[x]]))
      out.vals <- c(out.vals, vals)
    }
  }
  return(out.vals)
}
@


An important trait of a robust molecular subtyping scheme is that it should be present and discoverable in multiple datasets. We performed de novo clustering in \Sexpr{length(dataset.names)} independent ovarian datasets using the authors' original gene lists and clustering method. We compared these de novo cluster groupings to the labels from our implemented classifiers using the prediction strength statistic of Tibshirani and Walther, 2005.


In order to permit comparability between subtyping schemes, all datasets were filtered to patients with high-grade serous ovarian carcinomas.
%I performed clustering on 11 datasets from MetaGxOvarian:
%\Sexpr{dataset.names}

%Clustering was performed using a grid of 126 algorithm configurations:

%\vspace{10pt}

%\begin{tabular}{ | p{3cm} | p{3cm} |p{0.4cm} |} 
%\hline Algorithm & Gene Set & k \\ \hline 
%Consensus k-means NMF & TCGA gene set Tothill gene set Top 1000 by MAD Top 1500 by MAD Top 2000 by MAD Top 2500 by MAD Top 3000 by MAD & 2 3 4 5 6 7 8 9 10
%\\ \hline \end{tabular}
<<TCGA_pred_str, cache=FALSE>>=

.getSubtypeSpecificRandIndexValues <- function(classifier.subtypes.list, clustering.subtypes.list, ordered.classes, main) {
    consistency.list.of.matrices <- lapply(1:length(classifier.subtypes.list), function(x) {
      distance.per.subtype <- sapply(ordered.classes, function(subtype) {
        sapply(1:100, function(y) {
                subtype.specific.counts <- as.vector(table(clustering.subtypes.list[[x]][[y]][classifier.subtypes.list[[x]] == subtype]))
                return( sum(sapply(subtype.specific.counts, choose, k=2)) / (choose(sum(subtype.specific.counts), 2)))
               })
      })
      return(distance.per.subtype)
    })
    names(consistency.list.of.matrices) <- names(classifier.subtypes.list)
    distance.per.subtype.means <- sapply(consistency.list.of.matrices, function(x) apply(x, 2, mean))
    distance.per.subtype.means.m <- melt(distance.per.subtype.means)
    boxplot(value ~ Var1, distance.per.subtype.means.m, outline=FALSE, ylab="Subtype-specific Rand Index", main=main)
    stripchart(value ~ Var1, distance.per.subtype.means.m, add=TRUE, vertical=TRUE, method='jitter', pch=21)
    return(distance.per.subtype.means)
  }

tcga.ps.vals <- sapply(1:length(classifier.subtypes$Verhaak), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Verhaak[[x]], clustering.subtypes$tcga_nmf_4[[x]][[y]])$ps))
colnames(tcga.ps.vals) <- names(classifier.subtypes$Verhaak)

tcga.ordered.classes <- c("IMR", "DIF", "PRO", "MES")

@

<<tcga_pred_str_margin_trend, eval=TRUE>>=
# in progress
tcga.pred.str.trend <- lapply(names(classifier.subtypes$Verhaak), function(dataset.name) {
  # Get the index of the median clustering (since there is an even number of clusterings, use the median of the first 99)
#  median.clustering.index <- which(tcga.ps.vals[,dataset.name] == median(tcga.ps.vals[,dataset.name][-100]))[1]
  ps.matrix <- sapply(1:100, function(y) {
    sapply(1:length(classifier.subtypes$Verhaak[[dataset.name]]), function(x) {
      # calculate Prediction Strength; use the top x samples (by margin)
      margin.vals <- esets.not.rescaled.classified[[dataset.name]]$Verhaak.margins
      samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
      if(sum(samples.to.keep) <= 1) {
        return(NA)
      }
      current.ps <- ps.cluster(classifier.subtypes$Verhaak[[dataset.name]][samples.to.keep], clustering.subtypes$tcga_nmf_4[[dataset.name]][[y]][samples.to.keep])$ps
      return(current.ps)
    })
  })
  out.df <- data.frame(dataset.size=1:length(classifier.subtypes$Verhaak[[dataset.name]]), prediction.strength=apply(ps.matrix, 1, mean))
  return(out.df)
})

for(dataset.name in names(classifier.subtypes$Verhaak)) {
  tcga.pred.str.trend[[dataset.name]]$dataset.name <- dataset.name
}
tcga.pred.str.trend.combined <- Reduce(function(...) merge(..., all=TRUE), tcga.pred.str.trend)

ggplot(tcga.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()

tcga.mean.ps.df <- data.frame(dataset.size=unique(tcga.pred.str.trend.combined$dataset.size))
tcga.mean.ps.df$prediction.strength <- sapply(tcga.mean.ps.df$dataset.size, function(dataset.size) mean(tcga.pred.str.trend.combined$prediction.strength[tcga.pred.str.trend.combined$dataset.size==dataset.size]))

ggplot(tcga.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

<<tcga_pred_str_margin_trend_2>>=
ggplot(tcga.mean.ps.df, aes(y=prediction.strength, x = dataset.size)) + geom_point(size=4) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength: TCGA/Verhaak") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

<<Tothill_pred_str, cache=FALSE>>=

tothill.ps.vals <- sapply(1:length(classifier.subtypes$Helland), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Helland[[x]], clustering.subtypes$tothill_kmeans_4[[x]][[y]])$ps))
colnames(tothill.ps.vals) <- names(classifier.subtypes$Helland)

tothill.ordered.classes <- c("C2", "C4", "C5", "C1")
@

<<tothill_pred_str_margin_trend, eval=TRUE>>=
# in progress
tothill.pred.str.trend <- lapply(names(classifier.subtypes$Helland), function(dataset.name) {
  # Get the index of the median clustering (since there is an even number of clusterings, use the median of the first 99)
#  median.clustering.index <- which(tothill.ps.vals[,dataset.name] == median(tothill.ps.vals[,dataset.name][-100]))[1]
  ps.matrix <- sapply(1:100, function(y) {
    sapply(1:length(classifier.subtypes$Helland[[dataset.name]]), function(x) {
      # calculate Prediction Strength; use the top x samples (by margin)
      margin.vals <- esets.not.rescaled.classified[[dataset.name]]$Helland.margins
      samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
      if(sum(samples.to.keep) <= 1) {
        return(NA)
      }
      current.ps <- ps.cluster(classifier.subtypes$Helland[[dataset.name]][samples.to.keep], clustering.subtypes$tothill_kmeans_4[[dataset.name]][[y]][samples.to.keep])$ps
      return(current.ps)
    })
  })
  out.df <- data.frame(dataset.size=1:length(classifier.subtypes$Helland[[dataset.name]]), prediction.strength=apply(ps.matrix, 1, mean))
  return(out.df)
})

for(dataset.name in names(classifier.subtypes$Helland)) {
  tothill.pred.str.trend[[dataset.name]]$dataset.name <- dataset.name
}
tothill.pred.str.trend.combined <- Reduce(function(...) merge(..., all=TRUE), tothill.pred.str.trend)

ggplot(tothill.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()

tothill.mean.ps.df <- data.frame(dataset.size=unique(tothill.pred.str.trend.combined$dataset.size))
tothill.mean.ps.df$prediction.strength <- sapply(tothill.mean.ps.df$dataset.size, function(dataset.size) mean(tothill.pred.str.trend.combined$prediction.strength[tothill.pred.str.trend.combined$dataset.size==dataset.size]))

ggplot(tothill.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

<<tothill_pred_str_margin_trend_2>>=
ggplot(tothill.mean.ps.df, aes(y=prediction.strength, x = dataset.size)) + geom_point(size=4) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength: Tothill/Helland") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

<<Konecny_pred_str, cache=FALSE>>=

konecny.ps.vals <- sapply(1:length(classifier.subtypes$Konecny), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Konecny[[x]], clustering.subtypes$konecny_nmf_4[[x]][[y]])$ps))
colnames(konecny.ps.vals) <- names(classifier.subtypes$Konecny)

konecny.ordered.classes <- c("C1_immL", "C2_diffL", "C3_profL", "C4_mescL")

@

<<konecny_pred_str_margin_trend, eval=TRUE>>=
# in progress
konecny.pred.str.trend <- lapply(names(classifier.subtypes$Konecny), function(dataset.name) {
  # Get the index of the median clustering (since there is an even number of clusterings, use the median of the first 99)
#  median.clustering.index <- which(konecny.ps.vals[,dataset.name] == median(konecny.ps.vals[,dataset.name][-100]))[1]
  ps.matrix <- sapply(1:100, function(y) {
    sapply(1:length(classifier.subtypes$Konecny[[dataset.name]]), function(x) {
      # calculate Prediction Strength; use the top x samples (by margin)
      margin.vals <- esets.not.rescaled.classified[[dataset.name]]$Konecny.margins
      samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
      if(sum(samples.to.keep) <= 1) {
        return(NA)
      }
      current.ps <- ps.cluster(classifier.subtypes$Konecny[[dataset.name]][samples.to.keep], clustering.subtypes$konecny_nmf_4[[dataset.name]][[y]][samples.to.keep])$ps
      return(current.ps)
    })
  })
  out.df <- data.frame(dataset.size=1:length(classifier.subtypes$Konecny[[dataset.name]]), prediction.strength=apply(ps.matrix, 1, mean))
  return(out.df)
})

for(dataset.name in names(classifier.subtypes$Konecny)) {
  konecny.pred.str.trend[[dataset.name]]$dataset.name <- dataset.name
}
konecny.pred.str.trend.combined <- Reduce(function(...) merge(..., all=TRUE), konecny.pred.str.trend)

ggplot(konecny.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()

konecny.mean.ps.df <- data.frame(dataset.size=unique(konecny.pred.str.trend.combined$dataset.size))
konecny.mean.ps.df$prediction.strength <- sapply(konecny.mean.ps.df$dataset.size, function(dataset.size) mean(konecny.pred.str.trend.combined$prediction.strength[konecny.pred.str.trend.combined$dataset.size==dataset.size]))

ggplot(konecny.pred.str.trend.combined, aes(y=prediction.strength, x = dataset.size, colour = dataset.name)) + geom_point(size=1) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

<<konecny_pred_str_margin_trend_2>>=
ggplot(konecny.mean.ps.df, aes(y=prediction.strength, x = dataset.size)) + geom_point(size=4) + theme_bw() + xlab("Dataset Size") + ylab("Prediction Strength: Konecny") + ylim(0, 1) + ggtitle("Prediction Strength") + scale_x_reverse()
@

Each dataset was clustered according to our implementation of the clustering algorithms and gene sets of Konecny, TCGA, and Tothill. Each dataset was also classified using our implementation of the corresponding classification algorithms of Konecny, TCGA/Verhaak, and Tothill/Helland. This produced two sets of subtype labels for each validation dataset, from which we computed prediction strength.

We performed each clustering algorithm 100 times for each dataset, producing 100 prediction strength estimates per dataset. In the boxplot below, each data point represents the median estimated prediction strength for a dataset under a given subtyping clustering/classification scheme.

<<ps_combined_boxplot, out.width="0.7\\textwidth">>=

set.seed(900)
combined.ps <- sapply(list(Tothill=tothill.ps.vals, TCGA=tcga.ps.vals, Konecny=konecny.ps.vals), function(x) apply(x, 2, median))
combined.ps.m <- melt(combined.ps)
my.boxplot <- ggplot(combined.ps.m, aes(x=L1, y=value)) + stat_boxplot(geom='errorbar') + geom_boxplot(color="black") + geom_jitter(position=position_jitter(0.1)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2)) + theme_bw() + ggtitle("Robustness of Molecular Subtyping Schemes") + xlab("") + ylab("Prediction Strength") + xlab("Subtyping Scheme") + theme(plot.title=element_text(size=20, vjust=2)) + coord_cartesian(ylim = c(0, 1)) 
my.boxplot

@

\pagebreak
<<dataset_barplot, fig.width=8, fig.height=5>>=

par(mar=c(5.1,10,4.1,2.1))
barplot(sapply(esets.not.rescaled.classified[dataset.names], function(x) ncol(exprs(x))), horiz=TRUE, las=2, col="darkblue", main="HGS sample sizes")
par(mar=c(5.1, 4.1, 4.1, 2.1))
@

\pagebreak
\section{Prediction Strength: Supplemental}

For each classification and clustering algorithm, we produced a stripplot of the prediction strength values for each of the 100 clustering runs.

\pagebreak
\subsection{Verhaak/TCGA}
Using the subtype labels from the implemented Verhaak classifier, compared against de novo clustering with NMF, k = 4, and the same gene list used by the authors:


<<TCGA_pred_str_plot, width=800, height=800, out.width="0.6\\textwidth">>=


par(mar=c(10,4.1,4.1,2.1))
stripchart(as.data.frame(tcga.ps.vals), vertical=TRUE, method="jitter", pch=20, cex=0.8, las=2, ylim = c(0,1), ylab="Prediction Strength")
par(mar=c(5.1, 4.1, 4.1, 2.1))
@

<<tcga_adj_rand, out.width="0.6\\textwidth", eval=FALSE>>=

tcga.adj.rand <- .getSubtypeSpecificRandIndexValues(classifier.subtypes$Verhaak, clustering.subtypes$tcga_nmf_4, tcga.ordered.classes, main="TCGA")
@

\pagebreak
\subsection{Tothill/Helland}

Using the subtype labels from the implemented Tothill/Helland classifier, compared against de novo clustering with consensus k-means, k = 4, and the gene list produced by the methods used by the authors:


<<Tothill_pred_str_plot, width=800, height=800, out.width="0.6\\textwidth">>=

par(mar=c(10,4.1,4.1,2.1))
stripchart(as.data.frame(tothill.ps.vals), vertical=TRUE, method="jitter", pch=20, cex=0.8, las=2, ylim = c(0,1), ylab="Prediction Strength")
par(mar=c(5.1, 4.1, 4.1, 2.1))
@

<<tothill_adj_rand, out.width="0.6\\textwidth", eval=FALSE>>=

tothill.adj.rand <- .getSubtypeSpecificRandIndexValues(classifier.subtypes$Helland, clustering.subtypes$tothill_kmeans_4, tothill.ordered.classes, main="Tothill")
@

\pagebreak
\subsection{Konecny}
Using the subtype labels from the implemented Konecny classifier, compared against de novo clustering with consensus k-means, k = 4, and the top 2000 genes by MAD:

<<Konecny_pred_str_plot, width=800, height=800, out.width="0.6\\textwidth">>=

par(mar=c(10,4.1,4.1,2.1))
stripchart(as.data.frame(konecny.ps.vals), vertical=TRUE, method="jitter", pch=20, cex=0.8, las=2, ylim = c(0,1), ylab="Prediction Strength")
par(mar=c(5.1, 4.1, 4.1, 2.1))
@

<<konecny_adj_rand, out.width="0.6\\textwidth", eval=FALSE>>=

konecny.adj.rand <- .getSubtypeSpecificRandIndexValues(classifier.subtypes$Konecny, clustering.subtypes$konecny_nmf_4, konecny.ordered.classes, "Konecny")
@
