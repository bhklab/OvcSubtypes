

<<load_data_from_files, cache=TRUE>>=
knitr::opts_chunk$set(cache=TRUE)
load("esets.not.rescaled.classified.RData")
load("esets.not.rescaled.classified.concordant.RData")

# These are the dataset names with TCGA RNASeq removed
dataset.names <- names(esets.not.rescaled.classified)

clustering.subtypes <- list()

for(dirname in c("konecny_nmf_4", "tcga_nmf_4", "tothill_kmeans_4")) {
  cluster.classes <- list()
  for(current.eset.name in dataset.names) {
    cluster.classes[[current.eset.name]] <- list()
    filenames <- Sys.glob(paste0("may6_clusters/", dirname, "/", current.eset.name, "_*_classes.txt"))
    for(filename in filenames) {
      cluster.classes[[current.eset.name]][[length(cluster.classes[[current.eset.name]])+1]] <- scan(filename, what=character(0))
    }
  }
  clustering.subtypes[[dirname]] <- cluster.classes
}


classifier.subtypes <- lapply(c("Konecny.subtypes", "Verhaak.subtypes", "Helland.subtypes"), function(subtype.colname) {
  subtype.classes <- list()
  for(current.eset.name in dataset.names) {
    subtype.classes[[current.eset.name]] <- as.character(pData(esets.not.rescaled.classified[[current.eset.name]])[,subtype.colname])
  }
  return(subtype.classes)
})

names(classifier.subtypes) <- c("Konecny", "Verhaak", "Helland")

clustering.subtypes.concordant <- list()

for(dirname in c("konecny_nmf_4", "tcga_nmf_4", "tothill_kmeans_4")) {
  cluster.classes <- list()
  for(current.eset.name in dataset.names) {
    cluster.classes[[current.eset.name]] <- list()
    filenames <- Sys.glob(paste0("may6clusters_concordant/", dirname, "/", current.eset.name, "_*_classes.txt"))
    for(filename in filenames) {
      cluster.classes[[current.eset.name]][[length(cluster.classes[[current.eset.name]])+1]] <- scan(filename, what=character(0))
    }
  }
  clustering.subtypes.concordant[[dirname]] <- cluster.classes
}


classifier.subtypes.concordant <- lapply(c("Konecny.subtypes", "Verhaak.subtypes", "Helland.subtypes"), function(subtype.colname) {
  subtype.classes <- list()
  for(current.eset.name in dataset.names) {
    subtype.classes[[current.eset.name]] <- as.character(pData(esets.not.rescaled.classified.concordant[[current.eset.name]])[,subtype.colname])
  }
  return(subtype.classes)
})

names(classifier.subtypes.concordant) <- c("Konecny", "Verhaak", "Helland")

# Remove clustering/classification subtypes performed on the original dataset
#clustering.subtypes$tcga_nmf_4$TCGA <- NULL
#clustering.subtypes$tothill_kmeans_4$GSE9891 <- NULL
#classifier.subtypes$Verhaak$TCGA <- NULL
#classifier.subtypes$Helland$GSE9891 <- NULL

#clustering.subtypes.concordant$tcga_nmf_4$TCGA <- NULL
#clustering.subtypes.concordant$tothill_kmeans_4$GSE9891 <- NULL
#classifier.subtypes.concordant$Verhaak$TCGA <- NULL
#classifier.subtypes.concordant$Helland$GSE9891 <- NULL

@


An important trait of a robust molecular subtyping scheme is that it should be present and discoverable in multiple datasets. We performed de novo clustering in \Sexpr{length(dataset.names)} independent ovarian datasets using the authors' original gene lists and clustering method. We compared these de novo cluster groupings to the labels from our implemented classifiers using the prediction strength statistic of Tibshirani and Walther, 2005.


In order to permit comparability between subtyping schemes, all datasets were filtered to patients with late-stage, high-grade serous ovarian carcinomas.
%I performed clustering on 11 datasets from MetaGxOvarian:
%\Sexpr{dataset.names}

%Clustering was performed using a grid of 126 algorithm configurations:

%\vspace{10pt}

%\begin{tabular}{ | p{3cm} | p{3cm} |p{0.4cm} |} 
%\hline Algorithm & Gene Set & k \\ \hline 
%Consensus k-means NMF & TCGA gene set Tothill gene set Top 1000 by MAD Top 1500 by MAD Top 2000 by MAD Top 2500 by MAD Top 3000 by MAD & 2 3 4 5 6 7 8 9 10
%\\ \hline \end{tabular}
<<TCGA_pred_str, cache=TRUE>>=
tcga.ps.vals <- sapply(1:length(classifier.subtypes$Verhaak), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Verhaak[[x]], clustering.subtypes$tcga_nmf_4[[x]][[y]])$ps))
colnames(tcga.ps.vals) <- names(classifier.subtypes$Verhaak)

tcga.ps.vals.concordant <- sapply(1:length(classifier.subtypes.concordant$Verhaak), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes.concordant$Verhaak[[x]], clustering.subtypes.concordant$tcga_nmf_4[[x]][[y]])$ps))
colnames(tcga.ps.vals.concordant) <- names(classifier.subtypes.concordant$Verhaak)

tcga.ordered.classes <- c("IMR", "DIF", "PRO", "MES")

@

<<tcga_pred_str_margin_trend_computation_only_tcga>>=
#tcga.pred.str.trend.tcga.xvals <- seq(50, length(classifier.subtypes$Verhaak[[dataset.name]]), by=50)
tcga.pred.str.trend.tcga.xvals <- seq(0, 1, length.out = 11)[-11] # percent removed
tcga.pred.str.trend.tcga.ps.vals <- sapply(tcga.pred.str.trend.tcga.xvals, function(x) {
    # calculate Prediction Strength; use the top x samples (by margin)
    margin.vals <- esets.not.rescaled.classified$TCGA$Verhaak.margins
    samples.to.keep <- margin.vals > quantile(margin.vals, x)
    #samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
    ps.vals <- sapply(1:100, function(run.index) ps.cluster(classifier.subtypes$Verhaak$TCGA[samples.to.keep], clustering.subtypes$tcga_nmf_4$TCGA[[run.index]][samples.to.keep])$ps)
    return(mean(ps.vals))
  })

tcga.pred.str.trend.tcga <- data.frame(percent.removed=tcga.pred.str.trend.tcga.xvals, prediction.strength=tcga.pred.str.trend.tcga.ps.vals)
tcga.pred.str.trend.tcga$percent.removed <- tcga.pred.str.trend.tcga$percent.removed * 100
@

<<Tothill_pred_str, cache=TRUE>>=
tothill.ps.vals <- sapply(1:length(classifier.subtypes$Helland), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Helland[[x]], clustering.subtypes$tothill_kmeans_4[[x]][[y]])$ps))
colnames(tothill.ps.vals) <- names(classifier.subtypes$Helland)

tothill.ps.vals.concordant <- sapply(1:length(classifier.subtypes.concordant$Helland), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes.concordant$Helland[[x]], clustering.subtypes.concordant$tothill_kmeans_4[[x]][[y]])$ps))
colnames(tothill.ps.vals.concordant) <- names(classifier.subtypes.concordant$Helland)

tothill.ordered.classes <- c("C2", "C4", "C5", "C1")
@

<<tothill_pred_str_margin_trend_computation_only_tcga>>=
#tothill.pred.str.trend.tcga.xvals <- seq(50, length(classifier.subtypes$Helland[[dataset.name]]), by=50)
tothill.pred.str.trend.tcga.xvals <- seq(0, 1, length.out = 11)[-11] # percent removed
tothill.pred.str.trend.tcga.ps.vals <- sapply(tothill.pred.str.trend.tcga.xvals, function(x) {
    # calculate Prediction Strength; use the top x samples (by margin)
    margin.vals <- esets.not.rescaled.classified$TCGA$Helland.margins
    samples.to.keep <- margin.vals > quantile(margin.vals, x)
    #samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
    ps.vals <- sapply(1:100, function(run.index) ps.cluster(classifier.subtypes$Helland$TCGA[samples.to.keep], clustering.subtypes$tothill_kmeans_4$TCGA[[run.index]][samples.to.keep])$ps)
    return(mean(ps.vals))
  })

tothill.pred.str.trend.tcga <- data.frame(percent.removed=tothill.pred.str.trend.tcga.xvals, prediction.strength=tothill.pred.str.trend.tcga.ps.vals)
tothill.pred.str.trend.tcga$percent.removed <- tothill.pred.str.trend.tcga$percent.removed * 100
@

<<Konecny_pred_str, cache=TRUE>>=
konecny.ps.vals <- sapply(1:length(classifier.subtypes$Konecny), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes$Konecny[[x]], clustering.subtypes$konecny_nmf_4[[x]][[y]])$ps))
colnames(konecny.ps.vals) <- names(classifier.subtypes$Konecny)

konecny.ps.vals.concordant <- sapply(1:length(classifier.subtypes.concordant$Konecny), function(x) sapply(1:100, function(y) ps.cluster(classifier.subtypes.concordant$Konecny[[x]], clustering.subtypes.concordant$konecny_nmf_4[[x]][[y]])$ps))
colnames(konecny.ps.vals.concordant) <- names(classifier.subtypes.concordant$Konecny)

konecny.ordered.classes <- c("C1_immL", "C2_diffL", "C3_profL", "C4_mescL")
@

<<konecny_pred_str_margin_trend_computation_only_tcga>>=
#konecny.pred.str.trend.tcga.xvals <- seq(50, length(classifier.subtypes$Helland[[dataset.name]]), by=50)
konecny.pred.str.trend.tcga.xvals <- seq(0, 1, length.out = 11)[-11] # percent removed
konecny.pred.str.trend.tcga.ps.vals <- sapply(konecny.pred.str.trend.tcga.xvals, function(x) {
    # calculate Prediction Strength; use the top x samples (by margin)
    margin.vals <- esets.not.rescaled.classified$TCGA$Konecny.margins
    samples.to.keep <- margin.vals > quantile(margin.vals, x)
    #samples.to.keep <- margin.vals >= sort(margin.vals)[length(margin.vals)-x+1]
    ps.vals <- sapply(1:100, function(run.index) ps.cluster(classifier.subtypes$Konecny$TCGA[samples.to.keep], clustering.subtypes$konecny_nmf_4$TCGA[[run.index]][samples.to.keep])$ps)
    return(mean(ps.vals))
  })

konecny.pred.str.trend.tcga <- data.frame(percent.removed=konecny.pred.str.trend.tcga.xvals, prediction.strength=konecny.pred.str.trend.tcga.ps.vals)
konecny.pred.str.trend.tcga$percent.removed <- konecny.pred.str.trend.tcga$percent.removed * 100
@

Each dataset was clustered according to our implementation of the clustering algorithms and gene sets of Konecny, TCGA, and Tothill. Each dataset was also classified using our implementation of the corresponding classification algorithms of Konecny, TCGA/Verhaak, and Tothill/Helland. This produced two sets of subtype labels for each validation dataset, from which we computed prediction strength.

We performed each clustering algorithm 100 times for each dataset, producing 100 prediction strength estimates per dataset. In the boxplot below, each data point represents the mean estimated prediction strength for a dataset under a given subtyping clustering/classification scheme.

<<ps_combined_boxplot, out.width="0.7\\textwidth">>=

set.seed(900)
combined.ps <- lapply(list(Tothill=tothill.ps.vals, TCGA=tcga.ps.vals, Konecny=konecny.ps.vals), function(x) data.frame(dataset=colnames(x), pred.strength=apply(x, 2, mean)))
combined.ps.m <- melt(combined.ps)
combined.ps.m$variable <- NULL

ggplot(combined.ps.m, aes(x=L1, y=value, fill="red")) + stat_boxplot(geom='errorbar', width=0.5) + geom_boxplot(color="black", outlier.shape=NA) + geom_jitter(position=position_jitter(0.1), cex=0.5) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2)) + theme_bw() + ggtitle("Robustness of Molecular Subtyping Schemes") + xlab("") + ylab("Prediction Strength") + xlab("Subtyping Scheme") + theme(plot.title=element_text(size=20, vjust=2)) + coord_cartesian(ylim = c(0, 1)) + theme(legend.position='none')
@

\pagebreak

Next, we compared the Prediction Strength for only the concordantly classified patients. Using only the patients classified concordantly using the classifiers of Helland, Verhaak, and Konecny, we performed each clustering algorithm 100 times for each dataset, producing 100 prediction strength estimates per dataset. Each data point in the boxplot below represents the mean estimated prediction strength for a dataset under a given subtyping clustering/classification scheme.

<<ps_paired_boxplots, fig.width=10, out.width="0.85\\textwidth">>=
set.seed(900)
combined.ps.concordant <- lapply(list(Tothill=tothill.ps.vals.concordant, TCGA=tcga.ps.vals.concordant, Konecny=konecny.ps.vals.concordant), function(x) data.frame(dataset=colnames(x), pred.strength=apply(x, 2, mean)))
combined.ps.concordant.m <- melt(combined.ps.concordant)
combined.ps.concordant.m$variable <- NULL

combined.ps.concordant.m$Data <- "Concordant"
combined.ps.m$Data <- "All"

pred.str.df <- rbind(combined.ps.m, combined.ps.concordant.m)

colnames(pred.str.df)[2:3] <- c("pred.strength", "Method")

#ggplot(pred.str.df, aes(x=interaction(Data, Method), y=pred.strength)) + geom_boxplot(aes(fill=Data), outlier.size=0) + geom_line(aes(group=interaction(dataset, Method)), alpha=0.2, cex=0.5) + geom_jitter(position=position_jitter(0), cex=0.3) + theme_bw() + ggtitle("Robustness: All Data and Concordant Cases") + xlab("Subtyping Scheme") + ylab("Prediction Strength") + theme(plot.title=element_text(size=20, vjust=2)) + coord_cartesian(ylim = c(0, 1))  + scale_x_discrete(labels=c("                        Konecny", "", "                        TCGA", "", "                     Tothill", ""))

ggplot(pred.str.df, aes(x=interaction(Data, Method), y=pred.strength)) + stat_boxplot(geom='errorbar', width=0.5) + geom_boxplot(aes(fill=Data), outlier.shape=NA) + geom_jitter(position=position_jitter(0.1), cex=0.5) + theme_bw() + ggtitle("Robustness: All Data and Concordant Cases") + xlab("Subtyping Scheme") + ylab("Prediction Strength") + theme(plot.title=element_text(size=20, vjust=2)) + coord_cartesian(ylim = c(0, 1))  + scale_x_discrete(labels=c("                        Konecny", "", "                        TCGA", "", "                     Tothill", ""))

@

The Wilcoxon signed-rank test yields p-values of \Sexpr{sprintf("%.2e, %.2e, and %.2e", wilcox.test(combined.ps$Konecny$pred.strength, combined.ps.concordant$Konecny$pred.strength, paired=TRUE)$p.value, wilcox.test(combined.ps$TCGA$pred.strength, combined.ps.concordant$TCGA$pred.strength, paired=TRUE)$p.value, wilcox.test(combined.ps$Tothill$pred.strength, combined.ps.concordant$Tothill$pred.strength, paired=TRUE)$p.value)} respectively for Konecny, TCGA, and Tothill.

\pagebreak
\subsection{Tothill/Helland}
For the clustering algorithm and classifier described in Tothill (2008) and Helland (2011), we observed an increase in robustness of subtypes in the TCGA dataset.
<<tothill_pred_str_margin_trend_tcga>>=

ggplot(tothill.pred.str.trend.tcga, aes(y=prediction.strength, x = percent.removed, fill="TCGA")) + geom_point(size=2, colour="#E76BF3") + theme_bw() + xlab("Percent Removed") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength Trend: Tothill/Helland") + geom_line(colour="#E76BF3") + theme(plot.title=element_text(size=20)) + guides(fill=guide_legend(title="Dataset"))
@
This plot shows the prediction stregth trend for the TCGA dataset using the methods of Tothill/Helland, with Prediction Strength shown as a function of percentage of dataset removed. As previously described, we used classifier margins to determine cutoffs, and subsetted the pre-clustered and pre-classified datasets. From the 100 cluster runs, we used the run that produced the median prediction strength for each full dataset.

\pagebreak
\subsection{Konecny}
<<konecny_pred_str_margin_trend_tcga>>=

ggplot(konecny.pred.str.trend.tcga, aes(y=prediction.strength, x = percent.removed, fill="TCGA")) + geom_point(size=2, colour="#E76BF3") + theme_bw() + xlab("Percent Removed") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength Trend: Konecny") + geom_line(colour="#E76BF3") + theme(plot.title=element_text(size=20)) + guides(fill=guide_legend(title="Dataset"))
@

This plot shows the prediction stregth trend for the TCGA dataset using the methods of Konecny, with Prediction Strength shown as a function of percentage of dataset removed. As previously described, we used classifier margins to determine cutoffs, and subsetted the pre-clustered and pre-classified datasets. From the 100 cluster runs, we used the run that produced the median prediction strength for each full dataset.

\pagebreak

We computed Prediction Strength using all three methods on the TCGA dataset. Using the 100 cluster runs for each method, prediction strength was computed using various margin cutoffs. Each point represents the mean prediction strength between 100 cluster runs. Note that the Verhaak classifier was originally developed using the TCGA dataset.

<<tcga-together>>=
all.tcga <- cbind(tcga.pred.str.trend.tcga, tothill.pred.str.trend.tcga$prediction.strength, konecny.pred.str.trend.tcga$prediction.strength)

colnames(all.tcga)[2:4] <- c("TCGA", "Tothill", "Konecny")
all.tcga.m <- melt(all.tcga, id="percent.removed")
colnames(all.tcga.m)[2:3] <- c("Method", "Prediction.Strength")

ggplot(all.tcga.m, aes(y=Prediction.Strength, x = percent.removed, colour=Method)) + geom_point(size=2) + theme_bw() + xlab("Percent Removed") + ylab("Prediction Strength") + ylim(0, 1) + ggtitle("Prediction Strength Trend using TCGA Data") + geom_line() + theme(plot.title=element_text(size=20)) + guides(fill=guide_legend(title="Dataset")) + scale_x_continuous(breaks=seq(0, 100, 20), limits=c(0,100)) + geom_hline(aes(yintercept=0.8), linetype='dashed') + geom_hline(aes(yintercept=0.9), linetype='dashed') + scale_y_continuous(breaks=seq(0, 1, 0.2), limits=c(0,1))
@

